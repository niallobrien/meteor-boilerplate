{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":["inherits","class-call-check"]},"ignored":false,"code":"/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\nAccountsClient = (function (_AccountsCommon) {\n  babelHelpers.inherits(AccountsClient, _AccountsCommon);\n\n  function AccountsClient(options) {\n    babelHelpers.classCallCheck(this, AccountsClient);\n\n    _AccountsCommon.call(this, options);\n\n    this._loggingIn = false;\n    this._loggingInDeps = new Tracker.Dependency();\n\n    this._loginServicesHandle = this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    this._pageLoadLoginCallbacks = [];\n    this._pageLoadLoginAttemptInfo = null;\n\n    // Defined in url_client.js.\n    this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    this._initLocalStorage();\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n\n  AccountsClient.prototype.userId = (function () {\n    function userId() {\n      return this.connection.userId();\n    }\n\n    return userId;\n  })();\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n\n  AccountsClient.prototype._setLoggingIn = (function () {\n    function _setLoggingIn(x) {\n      if (this._loggingIn !== x) {\n        this._loggingIn = x;\n        this._loggingInDeps.changed();\n      }\n    }\n\n    return _setLoggingIn;\n  })();\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n\n  AccountsClient.prototype.loggingIn = (function () {\n    function loggingIn() {\n      this._loggingInDeps.depend();\n      return this._loggingIn;\n    }\n\n    return loggingIn;\n  })();\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n\n  AccountsClient.prototype.logout = (function () {\n    function logout(callback) {\n      var self = this;\n      self.connection.apply('logout', [], {\n        wait: true\n      }, function (error, result) {\n        if (error) {\n          callback && callback(error);\n        } else {\n          self.makeClientLoggedOut();\n          callback && callback();\n        }\n      });\n    }\n\n    return logout;\n  })();\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n\n  AccountsClient.prototype.logoutOtherClients = (function () {\n    function logoutOtherClients(callback) {\n      var self = this;\n\n      // We need to make two method calls: one to replace our current token,\n      // and another to remove all tokens except the current one. We want to\n      // call these two methods one after the other, without any other\n      // methods running between them. For example, we don't want `logout`\n      // to be called in between our two method calls (otherwise the second\n      // method call would return an error). Another example: we don't want\n      // logout to be called before the callback for `getNewToken`;\n      // otherwise we would momentarily log the user out and then write a\n      // new token to localStorage.\n      //\n      // To accomplish this, we make both calls as wait methods, and queue\n      // them one after the other, without spinning off the event loop in\n      // between. Even though we queue `removeOtherTokens` before\n      // `getNewToken`, we won't actually send the `removeOtherTokens` call\n      // until the `getNewToken` callback has finished running, because they\n      // are both wait methods.\n      self.connection.apply('getNewToken', [], { wait: true }, function (err, result) {\n        if (!err) {\n          self._storeLoginToken(self.userId(), result.token, result.tokenExpires);\n        }\n      });\n\n      self.connection.apply('removeOtherTokens', [], { wait: true }, function (err) {\n        callback && callback(err);\n      });\n    }\n\n    return logoutOtherClients;\n  })();\n\n  return AccountsClient;\n})(AccountsCommon);\n\nvar Ap = AccountsClient.prototype;\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n */\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAp.callLoginMethod = function (options) {\n  var self = this;\n\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f]) options[f] = function () {};\n  });\n\n  // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    }\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      // Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n        self.connection.onReconnect = function () {\n          reconnected = true;\n          // If our token was updated in storage, use the latest one.\n          var storedToken = self._storedLoginToken();\n          if (storedToken) {\n            result = {\n              token: storedToken,\n              tokenExpires: self._storedLoginTokenExpires()\n            };\n          }\n          if (!result.tokenExpires) result.tokenExpires = self._tokenExpiration(new Date());\n          if (self._tokenExpiresSoon(result.tokenExpires)) {\n            self.makeClientLoggedOut();\n          } else {\n            self.callLoginMethod({\n              methodArguments: [{ resume: result.token }],\n              // Reconnect quiescence ensures that the user doesn't see an\n              // intermediate state before the login method finishes. So we don't\n              // need to show a logging-in animation.\n              _suppressLoggingIn: true,\n              userCallback: function (error) {\n                var storedTokenNow = self._storedLoginToken();\n                if (error) {\n                  // If we had a login error AND the current stored token is the\n                  // one that we tried to log in with, then declare ourselves\n                  // logged out. If there's a token in storage but it's not the\n                  // token that we tried to log in with, we don't know anything\n                  // about whether that token is valid or not, so do nothing. The\n                  // periodic localStorage poll will decide if we are logged in or\n                  // out with this token, if it hasn't already. Of course, even\n                  // with this check, another tab could insert a new valid token\n                  // immediately before we clear localStorage here, which would\n                  // lead to both tabs being logged out, but by checking the token\n                  // in storage right now we hope to make that unlikely to happen.\n                  //\n                  // If there is no token in storage right now, we don't have to\n                  // do anything; whatever code removed the token from storage was\n                  // responsible for calling `makeClientLoggedOut()`, or the\n                  // periodic localStorage poll will call `makeClientLoggedOut`\n                  // eventually if another tab wiped the token from storage.\n                  if (storedTokenNow && storedTokenNow === result.token) {\n                    self.makeClientLoggedOut();\n                  }\n                }\n                // Possibly a weird callback to call, but better than nothing if\n                // there is a reconnect between \"login result received\" and \"data\n                // ready\".\n                loginCallbacks(error);\n              } });\n          }\n        };\n      }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected) return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    self._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn) self._setLoggingIn(true);\n  self.connection.apply(options.methodName, options.methodArguments, { wait: true, onResultReceived: onResultReceived }, loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  this._unstoreLoginToken();\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n  this.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n */\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n */\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n\n///\n/// LOGIN SERVICES\n///\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n};\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n};\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}","ast":null,"map":{"version":3,"sources":["/accounts_client.js"],"names":[],"mappings":"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","file":"/accounts_client.js.map","sourcesContent":["/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\nAccountsClient = class AccountsClient extends AccountsCommon {\n  constructor(options) {\n    super(options);\n\n    this._loggingIn = false;\n    this._loggingInDeps = new Tracker.Dependency;\n\n    this._loginServicesHandle =\n      this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    this._pageLoadLoginCallbacks = [];\n    this._pageLoadLoginAttemptInfo = null;\n\n    // Defined in url_client.js.\n    this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    this._initLocalStorage();\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n  userId() {\n    return this.connection.userId();\n  }\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n  _setLoggingIn(x) {\n    if (this._loggingIn !== x) {\n      this._loggingIn = x;\n      this._loggingInDeps.changed();\n    }\n  }\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  loggingIn() {\n    this._loggingInDeps.depend();\n    return this._loggingIn;\n  }\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logout(callback) {\n    var self = this;\n    self.connection.apply('logout', [], {\n      wait: true\n    }, function (error, result) {\n      if (error) {\n        callback && callback(error);\n      } else {\n        self.makeClientLoggedOut();\n        callback && callback();\n      }\n    });\n  }\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logoutOtherClients(callback) {\n    var self = this;\n\n    // We need to make two method calls: one to replace our current token,\n    // and another to remove all tokens except the current one. We want to\n    // call these two methods one after the other, without any other\n    // methods running between them. For example, we don't want `logout`\n    // to be called in between our two method calls (otherwise the second\n    // method call would return an error). Another example: we don't want\n    // logout to be called before the callback for `getNewToken`;\n    // otherwise we would momentarily log the user out and then write a\n    // new token to localStorage.\n    //\n    // To accomplish this, we make both calls as wait methods, and queue\n    // them one after the other, without spinning off the event loop in\n    // between. Even though we queue `removeOtherTokens` before\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\n    // until the `getNewToken` callback has finished running, because they\n    // are both wait methods.\n    self.connection.apply(\n      'getNewToken',\n      [],\n      { wait: true },\n      function (err, result) {\n        if (! err) {\n          self._storeLoginToken(\n            self.userId(),\n            result.token,\n            result.tokenExpires\n          );\n        }\n      }\n    );\n\n    self.connection.apply(\n      'removeOtherTokens',\n      [],\n      { wait: true },\n      function (err) {\n        callback && callback(err);\n      }\n    );\n  }\n};\n\nvar Ap = AccountsClient.prototype;\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n */\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAp.callLoginMethod = function (options) {\n  var self = this;\n\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f])\n      options[f] = function () {};\n  });\n\n  // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    }\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      // Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n      self.connection.onReconnect = function () {\n        reconnected = true;\n        // If our token was updated in storage, use the latest one.\n        var storedToken = self._storedLoginToken();\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: self._storedLoginTokenExpires()\n          };\n        }\n        if (! result.tokenExpires)\n          result.tokenExpires = self._tokenExpiration(new Date());\n        if (self._tokenExpiresSoon(result.tokenExpires)) {\n          self.makeClientLoggedOut();\n        } else {\n          self.callLoginMethod({\n            methodArguments: [{resume: result.token}],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function (error) {\n              var storedTokenNow = self._storedLoginToken();\n              if (error) {\n                // If we had a login error AND the current stored token is the\n                // one that we tried to log in with, then declare ourselves\n                // logged out. If there's a token in storage but it's not the\n                // token that we tried to log in with, we don't know anything\n                // about whether that token is valid or not, so do nothing. The\n                // periodic localStorage poll will decide if we are logged in or\n                // out with this token, if it hasn't already. Of course, even\n                // with this check, another tab could insert a new valid token\n                // immediately before we clear localStorage here, which would\n                // lead to both tabs being logged out, but by checking the token\n                // in storage right now we hope to make that unlikely to happen.\n                //\n                // If there is no token in storage right now, we don't have to\n                // do anything; whatever code removed the token from storage was\n                // responsible for calling `makeClientLoggedOut()`, or the\n                // periodic localStorage poll will call `makeClientLoggedOut`\n                // eventually if another tab wiped the token from storage.\n                if (storedTokenNow && storedTokenNow === result.token) {\n                  self.makeClientLoggedOut();\n                }\n              }\n              // Possibly a weird callback to call, but better than nothing if\n              // there is a reconnect between \"login result received\" and \"data\n              // ready\".\n              loginCallbacks(error);\n            }});\n        }\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected)\n      return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    self._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\n        \"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn)\n    self._setLoggingIn(true);\n  self.connection.apply(\n    options.methodName,\n    options.methodArguments,\n    {wait: true, onResultReceived: onResultReceived},\n    loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  this._unstoreLoginToken();\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n  this.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n */\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n */\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n\n\n///\n/// LOGIN SERVICES\n///\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n};\n\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n};\n\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}\n"]},"hash":"4fdec8da318afb6645e0bf67b46afd1738db4222"}
