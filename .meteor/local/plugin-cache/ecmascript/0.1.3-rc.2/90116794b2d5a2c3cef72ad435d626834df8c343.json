{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"var Ap = AccountsClient.prototype;\n\n// This file deals with storing a login token and user id in the\n// browser's localStorage facility. It polls local storage every few\n// seconds to synchronize login state between multiple tabs in the same\n// browser.\n\n// Login with a Meteor access token. This is the only public function\n// here.\nMeteor.loginWithToken = function (token, callback) {\n  return Accounts.loginWithToken(token, callback);\n};\n\nAp.loginWithToken = function (token, callback) {\n  this.callLoginMethod({\n    methodArguments: [{\n      resume: token\n    }],\n    userCallback: callback\n  });\n};\n\n// Semi-internal API. Call this function to re-enable auto login after\n// if it was disabled at startup.\nAp._enableAutoLogin = function () {\n  this._autoLoginEnabled = true;\n  this._pollStoredLoginToken();\n};\n\n///\n/// STORING\n///\n\n// Call this from the top level of the test file for any test that does\n// logging in and out, to protect multiple tabs running the same tests\n// simultaneously from interfering with each others' localStorage.\nAp._isolateLoginTokenForTest = function () {\n  this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\n  this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\n};\n\nAp._storeLoginToken = function (userId, token, tokenExpires) {\n  Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\n  if (!tokenExpires) tokenExpires = this._tokenExpiration(new Date());\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = token;\n};\n\nAp._unstoreLoginToken = function () {\n  Meteor._localStorage.removeItem(this.USER_ID_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = null;\n};\n\n// This is private, but it is exported for now because it is used by a\n// test in accounts-password.\n//\nAp._storedLoginToken = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\n};\n\nAp._storedLoginTokenExpires = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n};\n\nAp._storedUserId = function () {\n  return Meteor._localStorage.getItem(this.USER_ID_KEY);\n};\n\nAp._unstoreLoginTokenIfExpiresSoon = function () {\n  var tokenExpires = this._storedLoginTokenExpires();\n  if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\n    this._unstoreLoginToken();\n  }\n};\n\n///\n/// AUTO-LOGIN\n///\n\nAp._initLocalStorage = function () {\n  var self = this;\n\n  // Key names to use in localStorage\n  self.LOGIN_TOKEN_KEY = \"Meteor.loginToken\";\n  self.LOGIN_TOKEN_EXPIRES_KEY = \"Meteor.loginTokenExpires\";\n  self.USER_ID_KEY = \"Meteor.userId\";\n\n  var rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n  if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\n    // We want to keep using the same keys for existing apps that do not\n    // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\n    // to log in again after an app updates to a version of Meteor that\n    // contains this code, but it's generally preferable to namespace the\n    // keys so that connections from distinct apps to distinct DDP URLs\n    // will be distinct in Meteor._localStorage.\n    var namespace = \":\" + this.connection._stream.rawUrl;\n    if (rootUrlPathPrefix) {\n      namespace += \":\" + rootUrlPathPrefix;\n    }\n    self.LOGIN_TOKEN_KEY += namespace;\n    self.LOGIN_TOKEN_EXPIRES_KEY += namespace;\n    self.USER_ID_KEY += namespace;\n  }\n\n  if (self._autoLoginEnabled) {\n    // Immediately try to log in via local storage, so that any DDP\n    // messages are sent after we have established our user account\n    self._unstoreLoginTokenIfExpiresSoon();\n    var token = self._storedLoginToken();\n    if (token) {\n      // On startup, optimistically present us as logged in while the\n      // request is in flight. This reduces page flicker on startup.\n      var userId = self._storedUserId();\n      userId && self.connection.setUserId(userId);\n      self.loginWithToken(token, function (err) {\n        if (err) {\n          Meteor._debug(\"Error logging in with token: \" + err);\n          self.makeClientLoggedOut();\n        }\n\n        self._pageLoadLogin({\n          type: \"resume\",\n          allowed: !err,\n          error: err,\n          methodName: \"login\",\n          // XXX This is duplicate code with loginWithToken, but\n          // loginWithToken can also be called at other times besides\n          // page load.\n          methodArguments: [{ resume: token }]\n        });\n      });\n    }\n  }\n\n  // Poll local storage every 3 seconds to login if someone logged in in\n  // another tab\n  self._lastLoginTokenWhenPolled = token;\n\n  if (self._pollIntervalTimer) {\n    // Unlikely that _initLocalStorage will be called more than once for\n    // the same AccountsClient instance, but just in case...\n    clearInterval(self._pollIntervalTimer);\n  }\n\n  self._pollIntervalTimer = setInterval(function () {\n    self._pollStoredLoginToken();\n  }, 3000);\n};\n\nAp._pollStoredLoginToken = function () {\n  var self = this;\n\n  if (!self._autoLoginEnabled) {\n    return;\n  }\n\n  var currentLoginToken = self._storedLoginToken();\n\n  // != instead of !== just to make sure undefined and null are treated the same\n  if (self._lastLoginTokenWhenPolled != currentLoginToken) {\n    if (currentLoginToken) {\n      self.loginWithToken(currentLoginToken, function (err) {\n        if (err) {\n          self.makeClientLoggedOut();\n        }\n      });\n    } else {\n      self.logout();\n    }\n  }\n\n  self._lastLoginTokenWhenPolled = currentLoginToken;\n};","ast":null,"map":{"version":3,"sources":["/localstorage_token.js"],"names":[],"mappings":"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","file":"/localstorage_token.js.map","sourcesContent":["var Ap = AccountsClient.prototype;\n\n// This file deals with storing a login token and user id in the\n// browser's localStorage facility. It polls local storage every few\n// seconds to synchronize login state between multiple tabs in the same\n// browser.\n\n// Login with a Meteor access token. This is the only public function\n// here.\nMeteor.loginWithToken = function (token, callback) {\n  return Accounts.loginWithToken(token, callback);\n};\n\nAp.loginWithToken = function (token, callback) {\n  this.callLoginMethod({\n    methodArguments: [{\n      resume: token\n    }],\n    userCallback: callback\n  });\n};\n\n// Semi-internal API. Call this function to re-enable auto login after\n// if it was disabled at startup.\nAp._enableAutoLogin = function () {\n  this._autoLoginEnabled = true;\n  this._pollStoredLoginToken();\n};\n\n\n///\n/// STORING\n///\n\n// Call this from the top level of the test file for any test that does\n// logging in and out, to protect multiple tabs running the same tests\n// simultaneously from interfering with each others' localStorage.\nAp._isolateLoginTokenForTest = function () {\n  this.LOGIN_TOKEN_KEY = this.LOGIN_TOKEN_KEY + Random.id();\n  this.USER_ID_KEY = this.USER_ID_KEY + Random.id();\n};\n\nAp._storeLoginToken = function (userId, token, tokenExpires) {\n  Meteor._localStorage.setItem(this.USER_ID_KEY, userId);\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_KEY, token);\n  if (! tokenExpires)\n    tokenExpires = this._tokenExpiration(new Date());\n  Meteor._localStorage.setItem(this.LOGIN_TOKEN_EXPIRES_KEY, tokenExpires);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = token;\n};\n\nAp._unstoreLoginToken = function () {\n  Meteor._localStorage.removeItem(this.USER_ID_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_KEY);\n  Meteor._localStorage.removeItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  this._lastLoginTokenWhenPolled = null;\n};\n\n// This is private, but it is exported for now because it is used by a\n// test in accounts-password.\n//\nAp._storedLoginToken = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_KEY);\n};\n\nAp._storedLoginTokenExpires = function () {\n  return Meteor._localStorage.getItem(this.LOGIN_TOKEN_EXPIRES_KEY);\n};\n\nAp._storedUserId = function () {\n  return Meteor._localStorage.getItem(this.USER_ID_KEY);\n};\n\nAp._unstoreLoginTokenIfExpiresSoon = function () {\n  var tokenExpires = this._storedLoginTokenExpires();\n  if (tokenExpires && this._tokenExpiresSoon(new Date(tokenExpires))) {\n    this._unstoreLoginToken();\n  }\n};\n\n///\n/// AUTO-LOGIN\n///\n\nAp._initLocalStorage = function () {\n  var self = this;\n\n  // Key names to use in localStorage\n  self.LOGIN_TOKEN_KEY = \"Meteor.loginToken\";\n  self.LOGIN_TOKEN_EXPIRES_KEY = \"Meteor.loginTokenExpires\";\n  self.USER_ID_KEY = \"Meteor.userId\";\n\n  var rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX;\n  if (rootUrlPathPrefix || this.connection !== Meteor.connection) {\n    // We want to keep using the same keys for existing apps that do not\n    // set a custom ROOT_URL_PATH_PREFIX, so that most users will not have\n    // to log in again after an app updates to a version of Meteor that\n    // contains this code, but it's generally preferable to namespace the\n    // keys so that connections from distinct apps to distinct DDP URLs\n    // will be distinct in Meteor._localStorage.\n    var namespace = \":\" + this.connection._stream.rawUrl;\n    if (rootUrlPathPrefix) {\n      namespace += \":\" + rootUrlPathPrefix;\n    }\n    self.LOGIN_TOKEN_KEY += namespace;\n    self.LOGIN_TOKEN_EXPIRES_KEY += namespace;\n    self.USER_ID_KEY += namespace;\n  }\n\n  if (self._autoLoginEnabled) {\n    // Immediately try to log in via local storage, so that any DDP\n    // messages are sent after we have established our user account\n    self._unstoreLoginTokenIfExpiresSoon();\n    var token = self._storedLoginToken();\n    if (token) {\n      // On startup, optimistically present us as logged in while the\n      // request is in flight. This reduces page flicker on startup.\n      var userId = self._storedUserId();\n      userId && self.connection.setUserId(userId);\n      self.loginWithToken(token, function (err) {\n        if (err) {\n          Meteor._debug(\"Error logging in with token: \" + err);\n          self.makeClientLoggedOut();\n        }\n\n        self._pageLoadLogin({\n          type: \"resume\",\n          allowed: !err,\n          error: err,\n          methodName: \"login\",\n          // XXX This is duplicate code with loginWithToken, but\n          // loginWithToken can also be called at other times besides\n          // page load.\n          methodArguments: [{resume: token}]\n        });\n      });\n    }\n  }\n\n  // Poll local storage every 3 seconds to login if someone logged in in\n  // another tab\n  self._lastLoginTokenWhenPolled = token;\n\n  if (self._pollIntervalTimer) {\n    // Unlikely that _initLocalStorage will be called more than once for\n    // the same AccountsClient instance, but just in case...\n    clearInterval(self._pollIntervalTimer);\n  }\n\n  self._pollIntervalTimer = setInterval(function () {\n    self._pollStoredLoginToken();\n  }, 3000);\n};\n\nAp._pollStoredLoginToken = function () {\n  var self = this;\n\n  if (! self._autoLoginEnabled) {\n    return;\n  }\n\n  var currentLoginToken = self._storedLoginToken();\n\n  // != instead of !== just to make sure undefined and null are treated the same\n  if (self._lastLoginTokenWhenPolled != currentLoginToken) {\n    if (currentLoginToken) {\n      self.loginWithToken(currentLoginToken, function (err) {\n        if (err) {\n          self.makeClientLoggedOut();\n        }\n      });\n    } else {\n      self.logout();\n    }\n  }\n\n  self._lastLoginTokenWhenPolled = currentLoginToken;\n};\n"]},"hash":"90116794b2d5a2c3cef72ad435d626834df8c343"}
