[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar NpmModuleBcrypt = Package['npm-bcrypt'].NpmModuleBcrypt;\nvar Accounts = Package['accounts-base'].Accounts;\nvar AccountsServer = Package['accounts-base'].AccountsServer;\nvar SRP = Package.srp.SRP;\nvar SHA256 = Package.sha.SHA256;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar Email = Package.email.Email;\nvar EmailInternals = Package.email.EmailInternals;\nvar Random = Package.random.Random;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                 //\n// packages/accounts-password/email_templates.js                                                   //\n//                                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                   //\n/**                                                                                                // 1\n * @summary Options to customize emails sent from the Accounts system.                             // 2\n * @locus Server                                                                                   // 3\n */                                                                                                // 4\nAccounts.emailTemplates = {                                                                        // 5\n  from: \"Meteor Accounts <no-reply@meteor.com>\",                                                   // 6\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),                   // 7\n                                                                                                   // 8\n  resetPassword: {                                                                                 // 9\n    subject: function(user) {                                                                      // 10\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;                  // 11\n    },                                                                                             // 12\n    text: function(user, url) {                                                                    // 13\n      var greeting = (user.profile && user.profile.name) ?                                         // 14\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";                                       // 15\n      return greeting + \"\\n\"                                                                       // 16\n        + \"\\n\"                                                                                     // 17\n        + \"To reset your password, simply click the link below.\\n\"                                 // 18\n        + \"\\n\"                                                                                     // 19\n        + url + \"\\n\"                                                                               // 20\n        + \"\\n\"                                                                                     // 21\n        + \"Thanks.\\n\";                                                                             // 22\n    }                                                                                              // 23\n  },                                                                                               // 24\n  verifyEmail: {                                                                                   // 25\n    subject: function(user) {                                                                      // 26\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;                 // 27\n    },                                                                                             // 28\n    text: function(user, url) {                                                                    // 29\n      var greeting = (user.profile && user.profile.name) ?                                         // 30\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";                                       // 31\n      return greeting + \"\\n\"                                                                       // 32\n        + \"\\n\"                                                                                     // 33\n        + \"To verify your account email, simply click the link below.\\n\"                           // 34\n        + \"\\n\"                                                                                     // 35\n        + url + \"\\n\"                                                                               // 36\n        + \"\\n\"                                                                                     // 37\n        + \"Thanks.\\n\";                                                                             // 38\n    }                                                                                              // 39\n  },                                                                                               // 40\n  enrollAccount: {                                                                                 // 41\n    subject: function(user) {                                                                      // 42\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;         // 43\n    },                                                                                             // 44\n    text: function(user, url) {                                                                    // 45\n      var greeting = (user.profile && user.profile.name) ?                                         // 46\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";                                       // 47\n      return greeting + \"\\n\"                                                                       // 48\n        + \"\\n\"                                                                                     // 49\n        + \"To start using the service, simply click the link below.\\n\"                             // 50\n        + \"\\n\"                                                                                     // 51\n        + url + \"\\n\"                                                                               // 52\n        + \"\\n\"                                                                                     // 53\n        + \"Thanks.\\n\";                                                                             // 54\n    }                                                                                              // 55\n  }                                                                                                // 56\n};                                                                                                 // 57\n                                                                                                   // 58\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                 //\n// packages/accounts-password/password_server.js                                                   //\n//                                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                   //\n/// BCRYPT                                                                                         // 1\n                                                                                                   // 2\nvar bcrypt = NpmModuleBcrypt;                                                                      // 3\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);                                                    // 4\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);                                              // 5\n                                                                                                   // 6\n// User records have a 'services.password.bcrypt' field on them to hold                            // 7\n// their hashed passwords (unless they have a 'services.password.srp'                              // 8\n// field, in which case they will be upgraded to bcrypt the next time                              // 9\n// they log in).                                                                                   // 10\n//                                                                                                 // 11\n// When the client sends a password to the server, it can either be a                              // 12\n// string (the plaintext password) or an object with keys 'digest' and                             // 13\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends                         // 14\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients                           // 15\n// that don't have access to SHA can just send plaintext passwords as                              // 16\n// strings.                                                                                        // 17\n//                                                                                                 // 18\n// When the server receives a plaintext password as a string, it always                            // 19\n// hashes it with SHA256 before passing it into bcrypt. When the server                            // 20\n// receives a password as an object, it asserts that the algorithm is                              // 21\n// \"sha-256\" and then passes the digest to bcrypt.                                                 // 22\n                                                                                                   // 23\n                                                                                                   // 24\nAccounts._bcryptRounds = 10;                                                                       // 25\n                                                                                                   // 26\n// Given a 'password' from the client, extract the string that we should                           // 27\n// bcrypt. 'password' can be one of:                                                               // 28\n//  - String (the plaintext password)                                                              // 29\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".                    // 30\n//                                                                                                 // 31\nvar getPasswordString = function (password) {                                                      // 32\n  if (typeof password === \"string\") {                                                              // 33\n    password = SHA256(password);                                                                   // 34\n  } else { // 'password' is an object                                                              // 35\n    if (password.algorithm !== \"sha-256\") {                                                        // 36\n      throw new Error(\"Invalid password hash algorithm. \" +                                        // 37\n                      \"Only 'sha-256' is allowed.\");                                               // 38\n    }                                                                                              // 39\n    password = password.digest;                                                                    // 40\n  }                                                                                                // 41\n  return password;                                                                                 // 42\n};                                                                                                 // 43\n                                                                                                   // 44\n// Use bcrypt to hash the password for storage in the database.                                    // 45\n// `password` can be a string (in which case it will be run through                                // 46\n// SHA256 before bcrypt) or an object with properties `digest` and                                 // 47\n// `algorithm` (in which case we bcrypt `password.digest`).                                        // 48\n//                                                                                                 // 49\nvar hashPassword = function (password) {                                                           // 50\n  password = getPasswordString(password);                                                          // 51\n  return bcryptHash(password, Accounts._bcryptRounds);                                             // 52\n};                                                                                                 // 53\n                                                                                                   // 54\n// Check whether the provided password matches the bcrypt'ed password in                           // 55\n// the database user record. `password` can be a string (in which case                             // 56\n// it will be run through SHA256 before bcrypt) or an object with                                  // 57\n// properties `digest` and `algorithm` (in which case we bcrypt                                    // 58\n// `password.digest`).                                                                             // 59\n//                                                                                                 // 60\nAccounts._checkPassword = function (user, password) {                                              // 61\n  var result = {                                                                                   // 62\n    userId: user._id                                                                               // 63\n  };                                                                                               // 64\n                                                                                                   // 65\n  password = getPasswordString(password);                                                          // 66\n                                                                                                   // 67\n  if (! bcryptCompare(password, user.services.password.bcrypt)) {                                  // 68\n    result.error = new Meteor.Error(403, \"Incorrect password\");                                    // 69\n  }                                                                                                // 70\n                                                                                                   // 71\n  return result;                                                                                   // 72\n};                                                                                                 // 73\nvar checkPassword = Accounts._checkPassword;                                                       // 74\n                                                                                                   // 75\n///                                                                                                // 76\n/// LOGIN                                                                                          // 77\n///                                                                                                // 78\n                                                                                                   // 79\nAccounts._findUserByQuery = function (query) {                                                     // 80\n  var user = null;                                                                                 // 81\n                                                                                                   // 82\n  if (query.id) {                                                                                  // 83\n    user = Meteor.users.findOne({ _id: query.id });                                                // 84\n  } else {                                                                                         // 85\n    var fieldName;                                                                                 // 86\n    var fieldValue;                                                                                // 87\n    if (query.username) {                                                                          // 88\n      fieldName = 'username';                                                                      // 89\n      fieldValue = query.username;                                                                 // 90\n    } else if (query.email) {                                                                      // 91\n      fieldName = 'emails.address';                                                                // 92\n      fieldValue = query.email;                                                                    // 93\n    } else {                                                                                       // 94\n      throw new Error(\"shouldn't happen (validation missed something)\");                           // 95\n    }                                                                                              // 96\n    var selector = {};                                                                             // 97\n    selector[fieldName] = fieldValue;                                                              // 98\n    user = Meteor.users.findOne(selector);                                                         // 99\n    // If user is not found, try a case insensitive lookup                                         // 100\n    if (!user) {                                                                                   // 101\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);                      // 102\n      var candidateUsers = Meteor.users.find(selector).fetch();                                    // 103\n      // No match if multiple candidates are found                                                 // 104\n      if (candidateUsers.length === 1) {                                                           // 105\n        user = candidateUsers[0];                                                                  // 106\n      }                                                                                            // 107\n    }                                                                                              // 108\n  }                                                                                                // 109\n                                                                                                   // 110\n  return user;                                                                                     // 111\n};                                                                                                 // 112\n                                                                                                   // 113\n/**                                                                                                // 114\n * @summary Finds the user with the specified username.                                            // 115\n * First tries to match username case sensitively; if that fails, it                               // 116\n * tries case insensitively; but if more than one user matches the case                            // 117\n * insensitive search, it returns null.                                                            // 118\n * @locus Server                                                                                   // 119\n * @param {String} username The username to look for                                               // 120\n * @returns {Object} A user if found, else null                                                    // 121\n */                                                                                                // 122\nAccounts.findUserByUsername = function (username) {                                                // 123\n  return Accounts._findUserByQuery({                                                               // 124\n    username: username                                                                             // 125\n  });                                                                                              // 126\n};                                                                                                 // 127\n                                                                                                   // 128\n/**                                                                                                // 129\n * @summary Finds the user with the specified email.                                               // 130\n * First tries to match email case sensitively; if that fails, it                                  // 131\n * tries case insensitively; but if more than one user matches the case                            // 132\n * insensitive search, it returns null.                                                            // 133\n * @locus Server                                                                                   // 134\n * @param {String} email The email address to look for                                             // 135\n * @returns {Object} A user if found, else null                                                    // 136\n */                                                                                                // 137\nAccounts.findUserByEmail = function (email) {                                                      // 138\n  return Accounts._findUserByQuery({                                                               // 139\n    email: email                                                                                   // 140\n  });                                                                                              // 141\n};                                                                                                 // 142\n                                                                                                   // 143\n// Generates a MongoDB selector that can be used to perform a fast case                            // 144\n// insensitive lookup for the given fieldName and string. Since MongoDB does                       // 145\n// not support case insensitive indexes, and case insensitive regex queries                        // 146\n// are slow, we construct a set of prefix selectors for all permutations of                        // 147\n// the first 4 characters ourselves. We first attempt to matching against                          // 148\n// these, and because 'prefix expression' regex queries do use indexes (see                        // 149\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),                        // 150\n// this has been found to greatly improve performance (from 1200ms to 5ms in a                     // 151\n// test with 1.000.000 users).                                                                     // 152\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {                          // 153\n  // Performance seems to improve up to 4 prefix characters                                        // 154\n  var prefix = string.substring(0, Math.min(string.length, 4));                                    // 155\n  var orClause = _.map(generateCasePermutationsForString(prefix),                                  // 156\n    function (prefixPermutation) {                                                                 // 157\n      var selector = {};                                                                           // 158\n      selector[fieldName] =                                                                        // 159\n        new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));                                 // 160\n      return selector;                                                                             // 161\n    });                                                                                            // 162\n  var caseInsensitiveClause = {};                                                                  // 163\n  caseInsensitiveClause[fieldName] =                                                               // 164\n    new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i')                                      // 165\n  return {$and: [{$or: orClause}, caseInsensitiveClause]};                                         // 166\n}                                                                                                  // 167\n                                                                                                   // 168\n// Generates permutations of all case variations of a given string.                                // 169\nvar generateCasePermutationsForString = function (string) {                                        // 170\n  var permutations = [''];                                                                         // 171\n  for (var i = 0; i < string.length; i++) {                                                        // 172\n    var ch = string.charAt(i);                                                                     // 173\n    permutations = _.flatten(_.map(permutations, function (prefix) {                               // 174\n      var lowerCaseChar = ch.toLowerCase();                                                        // 175\n      var upperCaseChar = ch.toUpperCase();                                                        // 176\n      // Don't add unneccesary permutations when ch is not a letter                                // 177\n      if (lowerCaseChar === upperCaseChar) {                                                       // 178\n        return [prefix + ch];                                                                      // 179\n      } else {                                                                                     // 180\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];                                   // 181\n      }                                                                                            // 182\n    }));                                                                                           // 183\n  }                                                                                                // 184\n  return permutations;                                                                             // 185\n}                                                                                                  // 186\n                                                                                                   // 187\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive                       // 189\n  // value, hence the _skipCaseInsensitiveChecksForTest check                                      // 190\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);                   // 191\n                                                                                                   // 192\n  if (fieldValue && !skipCheck) {                                                                  // 193\n    var matchedUsers = Meteor.users.find(                                                          // 194\n      selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();                        // 195\n                                                                                                   // 196\n    if (matchedUsers.length > 0 &&                                                                 // 197\n        // If we don't have a userId yet, any match we find is a duplicate                         // 198\n        (!ownUserId ||                                                                             // 199\n        // Otherwise, check to see if there are multiple matches or a match                        // 200\n        // that is not us                                                                          // 201\n        (matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {                         // 202\n      throw new Meteor.Error(403, displayName + \" already exists.\");                               // 203\n    }                                                                                              // 204\n  }                                                                                                // 205\n};                                                                                                 // 206\n                                                                                                   // 207\n// XXX maybe this belongs in the check package                                                     // 208\nvar NonEmptyString = Match.Where(function (x) {                                                    // 209\n  check(x, String);                                                                                // 210\n  return x.length > 0;                                                                             // 211\n});                                                                                                // 212\n                                                                                                   // 213\nvar userQueryValidator = Match.Where(function (user) {                                             // 214\n  check(user, {                                                                                    // 215\n    id: Match.Optional(NonEmptyString),                                                            // 216\n    username: Match.Optional(NonEmptyString),                                                      // 217\n    email: Match.Optional(NonEmptyString)                                                          // 218\n  });                                                                                              // 219\n  if (_.keys(user).length !== 1)                                                                   // 220\n    throw new Match.Error(\"User property must have exactly one field\");                            // 221\n  return true;                                                                                     // 222\n});                                                                                                // 223\n                                                                                                   // 224\nvar passwordValidator = Match.OneOf(                                                               // 225\n  String,                                                                                          // 226\n  { digest: String, algorithm: String }                                                            // 227\n);                                                                                                 // 228\n                                                                                                   // 229\n// Handler to login with a password.                                                               // 230\n//                                                                                                 // 231\n// The Meteor client sets options.password to an object with keys                                  // 232\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").                                 // 233\n//                                                                                                 // 234\n// For other DDP clients which don't have access to SHA, the handler                               // 235\n// also accepts the plaintext password in options.password as a string.                            // 236\n//                                                                                                 // 237\n// (It might be nice if servers could turn the plaintext password                                  // 238\n// option off. Or maybe it should be opt-in, not opt-out?                                          // 239\n// Accounts.config option?)                                                                        // 240\n//                                                                                                 // 241\n// Note that neither password option is secure without SSL.                                        // 242\n//                                                                                                 // 243\nAccounts.registerLoginHandler(\"password\", function (options) {                                     // 244\n  if (! options.password || options.srp)                                                           // 245\n    return undefined; // don't handle                                                              // 246\n                                                                                                   // 247\n  check(options, {                                                                                 // 248\n    user: userQueryValidator,                                                                      // 249\n    password: passwordValidator                                                                    // 250\n  });                                                                                              // 251\n                                                                                                   // 252\n                                                                                                   // 253\n  var user = Accounts._findUserByQuery(options.user);                                              // 254\n  if (!user)                                                                                       // 255\n    throw new Meteor.Error(403, \"User not found\");                                                 // 256\n                                                                                                   // 257\n  if (!user.services || !user.services.password ||                                                 // 258\n      !(user.services.password.bcrypt || user.services.password.srp))                              // 259\n    throw new Meteor.Error(403, \"User has no password set\");                                       // 260\n                                                                                                   // 261\n  if (!user.services.password.bcrypt) {                                                            // 262\n    if (typeof options.password === \"string\") {                                                    // 263\n      // The client has presented a plaintext password, and the user is                            // 264\n      // not upgraded to bcrypt yet. We don't attempt to tell the client                           // 265\n      // to upgrade to bcrypt, because it might be a standalone DDP                                // 266\n      // client doesn't know how to do such a thing.                                               // 267\n      var verifier = user.services.password.srp;                                                   // 268\n      var newVerifier = SRP.generateVerifier(options.password, {                                   // 269\n        identity: verifier.identity, salt: verifier.salt});                                        // 270\n                                                                                                   // 271\n      if (verifier.verifier !== newVerifier.verifier) {                                            // 272\n        return {                                                                                   // 273\n          userId: user._id,                                                                        // 274\n          error: new Meteor.Error(403, \"Incorrect password\")                                       // 275\n        };                                                                                         // 276\n      }                                                                                            // 277\n                                                                                                   // 278\n      return {userId: user._id};                                                                   // 279\n    } else {                                                                                       // 280\n      // Tell the client to use the SRP upgrade process.                                           // 281\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                         // 282\n        format: 'srp',                                                                             // 283\n        identity: user.services.password.srp.identity                                              // 284\n      }));                                                                                         // 285\n    }                                                                                              // 286\n  }                                                                                                // 287\n                                                                                                   // 288\n  return checkPassword(                                                                            // 289\n    user,                                                                                          // 290\n    options.password                                                                               // 291\n  );                                                                                               // 292\n});                                                                                                // 293\n                                                                                                   // 294\n// Handler to login using the SRP upgrade path. To use this login                                  // 295\n// handler, the client must provide:                                                               // 296\n//   - srp: H(identity + \":\" + password)                                                           // 297\n//   - password: a string or an object with properties 'digest' and 'algorithm'                    // 298\n//                                                                                                 // 299\n// We use `options.srp` to verify that the client knows the correct                                // 300\n// password without doing a full SRP flow. Once we've checked that, we                             // 301\n// upgrade the user to bcrypt and remove the SRP information from the                              // 302\n// user document.                                                                                  // 303\n//                                                                                                 // 304\n// The client ends up using this login handler after trying the normal                             // 305\n// login handler (above), which throws an error telling the client to                              // 306\n// try the SRP upgrade path.                                                                       // 307\n//                                                                                                 // 308\n// XXX COMPAT WITH 0.8.1.3                                                                         // 309\nAccounts.registerLoginHandler(\"password\", function (options) {                                     // 310\n  if (!options.srp || !options.password)                                                           // 311\n    return undefined; // don't handle                                                              // 312\n                                                                                                   // 313\n  check(options, {                                                                                 // 314\n    user: userQueryValidator,                                                                      // 315\n    srp: String,                                                                                   // 316\n    password: passwordValidator                                                                    // 317\n  });                                                                                              // 318\n                                                                                                   // 319\n  var user = Accounts._findUserByQuery(options.user);                                              // 320\n  if (!user)                                                                                       // 321\n    throw new Meteor.Error(403, \"User not found\");                                                 // 322\n                                                                                                   // 323\n  // Check to see if another simultaneous login has already upgraded                               // 324\n  // the user record to bcrypt.                                                                    // 325\n  if (user.services && user.services.password && user.services.password.bcrypt)                    // 326\n    return checkPassword(user, options.password);                                                  // 327\n                                                                                                   // 328\n  if (!(user.services && user.services.password && user.services.password.srp))                    // 329\n    throw new Meteor.Error(403, \"User has no password set\");                                       // 330\n                                                                                                   // 331\n  var v1 = user.services.password.srp.verifier;                                                    // 332\n  var v2 = SRP.generateVerifier(                                                                   // 333\n    null,                                                                                          // 334\n    {                                                                                              // 335\n      hashedIdentityAndPassword: options.srp,                                                      // 336\n      salt: user.services.password.srp.salt                                                        // 337\n    }                                                                                              // 338\n  ).verifier;                                                                                      // 339\n  if (v1 !== v2)                                                                                   // 340\n    return {                                                                                       // 341\n      userId: user._id,                                                                            // 342\n      error: new Meteor.Error(403, \"Incorrect password\")                                           // 343\n    };                                                                                             // 344\n                                                                                                   // 345\n  // Upgrade to bcrypt on successful login.                                                        // 346\n  var salted = hashPassword(options.password);                                                     // 347\n  Meteor.users.update(                                                                             // 348\n    user._id,                                                                                      // 349\n    {                                                                                              // 350\n      $unset: { 'services.password.srp': 1 },                                                      // 351\n      $set: { 'services.password.bcrypt': salted }                                                 // 352\n    }                                                                                              // 353\n  );                                                                                               // 354\n                                                                                                   // 355\n  return {userId: user._id};                                                                       // 356\n});                                                                                                // 357\n                                                                                                   // 358\n                                                                                                   // 359\n///                                                                                                // 360\n/// CHANGING                                                                                       // 361\n///                                                                                                // 362\n                                                                                                   // 363\n/**                                                                                                // 364\n * @summary Change a user's username. Use this instead of updating the                             // 365\n * database directly. The operation will fail if there is an existing user                         // 366\n * with a username only differing in case.                                                         // 367\n * @locus Server                                                                                   // 368\n * @param {String} userId The ID of the user to update.                                            // 369\n * @param {String} newUsername A new username for the user.                                        // 370\n */                                                                                                // 371\nAccounts.setUsername = function (userId, newUsername) {                                            // 372\n  check(userId, NonEmptyString);                                                                   // 373\n  check(newUsername, NonEmptyString);                                                              // 374\n                                                                                                   // 375\n  var user = Meteor.users.findOne(userId);                                                         // 376\n  if (!user)                                                                                       // 377\n    throw new Meteor.Error(403, \"User not found\");                                                 // 378\n                                                                                                   // 379\n  var oldUsername = user.username;                                                                 // 380\n                                                                                                   // 381\n  // Perform a case insensitive check fro duplicates before update                                 // 382\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);                // 383\n                                                                                                   // 384\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});                           // 385\n                                                                                                   // 386\n  // Perform another check after update, in case a matching user has been                          // 387\n  // inserted in the meantime                                                                      // 388\n  try {                                                                                            // 389\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);              // 390\n  } catch (ex) {                                                                                   // 391\n    // Undo update if the check fails                                                              // 392\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});                         // 393\n    throw ex;                                                                                      // 394\n  }                                                                                                // 395\n};                                                                                                 // 396\n                                                                                                   // 397\n// Let the user change their own password if they know the old                                     // 398\n// password. `oldPassword` and `newPassword` should be objects with keys                           // 399\n// `digest` and `algorithm` (representing the SHA256 of the password).                             // 400\n//                                                                                                 // 401\n// XXX COMPAT WITH 0.8.1.3                                                                         // 402\n// Like the login method, if the user hasn't been upgraded from SRP to                             // 403\n// bcrypt yet, then this method will throw an 'old password format'                                // 404\n// error. The client should call the SRP upgrade login handler and then                            // 405\n// retry this method again.                                                                        // 406\n//                                                                                                 // 407\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade                           // 408\n// errors thrown. The reasoning for this is that clients using this                                // 409\n// method directly will need to be updated anyway because we no longer                             // 410\n// support the SRP flow that they would have been doing to use this                                // 411\n// method previously.                                                                              // 412\nMeteor.methods({changePassword: function (oldPassword, newPassword) {                              // 413\n  check(oldPassword, passwordValidator);                                                           // 414\n  check(newPassword, passwordValidator);                                                           // 415\n                                                                                                   // 416\n  if (!this.userId)                                                                                // 417\n    throw new Meteor.Error(401, \"Must be logged in\");                                              // 418\n                                                                                                   // 419\n  var user = Meteor.users.findOne(this.userId);                                                    // 420\n  if (!user)                                                                                       // 421\n    throw new Meteor.Error(403, \"User not found\");                                                 // 422\n                                                                                                   // 423\n  if (!user.services || !user.services.password ||                                                 // 424\n      (!user.services.password.bcrypt && !user.services.password.srp))                             // 425\n    throw new Meteor.Error(403, \"User has no password set\");                                       // 426\n                                                                                                   // 427\n  if (! user.services.password.bcrypt) {                                                           // 428\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                           // 429\n      format: 'srp',                                                                               // 430\n      identity: user.services.password.srp.identity                                                // 431\n    }));                                                                                           // 432\n  }                                                                                                // 433\n                                                                                                   // 434\n  var result = checkPassword(user, oldPassword);                                                   // 435\n  if (result.error)                                                                                // 436\n    throw result.error;                                                                            // 437\n                                                                                                   // 438\n  var hashed = hashPassword(newPassword);                                                          // 439\n                                                                                                   // 440\n  // It would be better if this removed ALL existing tokens and replaced                           // 441\n  // the token for the current connection with a new one, but that would                           // 442\n  // be tricky, so we'll settle for just replacing all tokens other than                           // 443\n  // the one for the current connection.                                                           // 444\n  var currentToken = Accounts._getLoginToken(this.connection.id);                                  // 445\n  Meteor.users.update(                                                                             // 446\n    { _id: this.userId },                                                                          // 447\n    {                                                                                              // 448\n      $set: { 'services.password.bcrypt': hashed },                                                // 449\n      $pull: {                                                                                     // 450\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }                      // 451\n      },                                                                                           // 452\n      $unset: { 'services.password.reset': 1 }                                                     // 453\n    }                                                                                              // 454\n  );                                                                                               // 455\n                                                                                                   // 456\n  return {passwordChanged: true};                                                                  // 457\n}});                                                                                               // 458\n                                                                                                   // 459\n                                                                                                   // 460\n// Force change the users password.                                                                // 461\n                                                                                                   // 462\n/**                                                                                                // 463\n * @summary Forcibly change the password for a user.                                               // 464\n * @locus Server                                                                                   // 465\n * @param {String} userId The id of the user to update.                                            // 466\n * @param {String} newPassword A new password for the user.                                        // 467\n * @param {Object} [options]                                                                       // 468\n * @param {Object} options.logout Logout all current connections with this userId (default: true)  // 469\n */                                                                                                // 470\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {                          // 471\n  options = _.extend({logout: true}, options);                                                     // 472\n                                                                                                   // 473\n  var user = Meteor.users.findOne(userId);                                                         // 474\n  if (!user)                                                                                       // 475\n    throw new Meteor.Error(403, \"User not found\");                                                 // 476\n                                                                                                   // 477\n  var update = {                                                                                   // 478\n    $unset: {                                                                                      // 479\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3                                       // 480\n      'services.password.reset': 1                                                                 // 481\n    },                                                                                             // 482\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}                         // 483\n  };                                                                                               // 484\n                                                                                                   // 485\n  if (options.logout) {                                                                            // 486\n    update.$unset['services.resume.loginTokens'] = 1;                                              // 487\n  }                                                                                                // 488\n                                                                                                   // 489\n  Meteor.users.update({_id: user._id}, update);                                                    // 490\n};                                                                                                 // 491\n                                                                                                   // 492\n                                                                                                   // 493\n///                                                                                                // 494\n/// RESETTING VIA EMAIL                                                                            // 495\n///                                                                                                // 496\n                                                                                                   // 497\n// Method called by a user to request a password reset email. This is                              // 498\n// the start of the reset process.                                                                 // 499\nMeteor.methods({forgotPassword: function (options) {                                               // 500\n  check(options, {email: String});                                                                 // 501\n                                                                                                   // 502\n  var user = Meteor.users.findOne({\"emails.address\": options.email});                              // 503\n  if (!user)                                                                                       // 504\n    throw new Meteor.Error(403, \"User not found\");                                                 // 505\n                                                                                                   // 506\n  Accounts.sendResetPasswordEmail(user._id, options.email);                                        // 507\n}});                                                                                               // 508\n                                                                                                   // 509\n// send the user an email with a link that when opened allows the user                             // 510\n// to set a new password, without the old password.                                                // 511\n                                                                                                   // 512\n/**                                                                                                // 513\n * @summary Send an email with a link the user can use to reset their password.                    // 514\n * @locus Server                                                                                   // 515\n * @param {String} userId The id of the user to send email to.                                     // 516\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */                                                                                                // 518\nAccounts.sendResetPasswordEmail = function (userId, email) {                                       // 519\n  // Make sure the user exists, and email is one of their addresses.                               // 520\n  var user = Meteor.users.findOne(userId);                                                         // 521\n  if (!user)                                                                                       // 522\n    throw new Error(\"Can't find user\");                                                            // 523\n  // pick the first email if we weren't passed an email.                                           // 524\n  if (!email && user.emails && user.emails[0])                                                     // 525\n    email = user.emails[0].address;                                                                // 526\n  // make sure we have a valid email                                                               // 527\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))                         // 528\n    throw new Error(\"No such email for user.\");                                                    // 529\n                                                                                                   // 530\n  var token = Random.secret();                                                                     // 531\n  var when = new Date();                                                                           // 532\n  var tokenRecord = {                                                                              // 533\n    token: token,                                                                                  // 534\n    email: email,                                                                                  // 535\n    when: when                                                                                     // 536\n  };                                                                                               // 537\n  Meteor.users.update(userId, {$set: {                                                             // 538\n    \"services.password.reset\": tokenRecord                                                         // 539\n  }});                                                                                             // 540\n  // before passing to template, update user object with new token                                 // 541\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;                                // 542\n                                                                                                   // 543\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);                                       // 544\n                                                                                                   // 545\n  var options = {                                                                                  // 546\n    to: email,                                                                                     // 547\n    from: Accounts.emailTemplates.resetPassword.from                                               // 548\n      ? Accounts.emailTemplates.resetPassword.from(user)                                           // 549\n      : Accounts.emailTemplates.from,                                                              // 550\n    subject: Accounts.emailTemplates.resetPassword.subject(user)                                   // 551\n  };                                                                                               // 552\n                                                                                                   // 553\n  if (typeof Accounts.emailTemplates.resetPassword.text === 'function') {                          // 554\n    options.text =                                                                                 // 555\n      Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl);                          // 556\n  }                                                                                                // 557\n                                                                                                   // 558\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function')                            // 559\n    options.html =                                                                                 // 560\n      Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);                          // 561\n                                                                                                   // 562\n  if (typeof Accounts.emailTemplates.headers === 'object') {                                       // 563\n    options.headers = Accounts.emailTemplates.headers;                                             // 564\n  }                                                                                                // 565\n                                                                                                   // 566\n  Email.send(options);                                                                             // 567\n};                                                                                                 // 568\n                                                                                                   // 569\n// send the user an email informing them that their account was created, with                      // 570\n// a link that when opened both marks their email as verified and forces them                      // 571\n// to choose their password. The email must be one of the addresses in the                         // 572\n// user's emails field, or undefined to pick the first email automatically.                        // 573\n//                                                                                                 // 574\n// This is not called automatically. It must be called manually if you                             // 575\n// want to use enrollment emails.                                                                  // 576\n                                                                                                   // 577\n/**                                                                                                // 578\n * @summary Send an email with a link the user can use to set their initial password.              // 579\n * @locus Server                                                                                   // 580\n * @param {String} userId The id of the user to send email to.                                     // 581\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */                                                                                                // 583\nAccounts.sendEnrollmentEmail = function (userId, email) {                                          // 584\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.                          // 585\n                                                                                                   // 586\n  // Make sure the user exists, and email is in their addresses.                                   // 587\n  var user = Meteor.users.findOne(userId);                                                         // 588\n  if (!user)                                                                                       // 589\n    throw new Error(\"Can't find user\");                                                            // 590\n  // pick the first email if we weren't passed an email.                                           // 591\n  if (!email && user.emails && user.emails[0])                                                     // 592\n    email = user.emails[0].address;                                                                // 593\n  // make sure we have a valid email                                                               // 594\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))                         // 595\n    throw new Error(\"No such email for user.\");                                                    // 596\n                                                                                                   // 597\n  var token = Random.secret();                                                                     // 598\n  var when = new Date();                                                                           // 599\n  var tokenRecord = {                                                                              // 600\n    token: token,                                                                                  // 601\n    email: email,                                                                                  // 602\n    when: when                                                                                     // 603\n  };                                                                                               // 604\n  Meteor.users.update(userId, {$set: {                                                             // 605\n    \"services.password.reset\": tokenRecord                                                         // 606\n  }});                                                                                             // 607\n                                                                                                   // 608\n  // before passing to template, update user object with new token                                 // 609\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;                                // 610\n                                                                                                   // 611\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);                                       // 612\n                                                                                                   // 613\n  var options = {                                                                                  // 614\n    to: email,                                                                                     // 615\n    from: Accounts.emailTemplates.enrollAccount.from                                               // 616\n      ? Accounts.emailTemplates.enrollAccount.from(user)                                           // 617\n      : Accounts.emailTemplates.from,                                                              // 618\n    subject: Accounts.emailTemplates.enrollAccount.subject(user)                                   // 619\n  };                                                                                               // 620\n                                                                                                   // 621\n  if (typeof Accounts.emailTemplates.enrollAccount.text === 'function') {                          // 622\n    options.text =                                                                                 // 623\n      Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl);                          // 624\n  }                                                                                                // 625\n                                                                                                   // 626\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function')                            // 627\n    options.html =                                                                                 // 628\n      Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);                          // 629\n                                                                                                   // 630\n  if (typeof Accounts.emailTemplates.headers === 'object') {                                       // 631\n    options.headers = Accounts.emailTemplates.headers;                                             // 632\n  }                                                                                                // 633\n                                                                                                   // 634\n  Email.send(options);                                                                             // 635\n};                                                                                                 // 636\n                                                                                                   // 637\n                                                                                                   // 638\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change                           // 639\n// the users password, and log them in.                                                            // 640\nMeteor.methods({resetPassword: function (token, newPassword) {                                     // 641\n  var self = this;                                                                                 // 642\n  return Accounts._loginMethod(                                                                    // 643\n    self,                                                                                          // 644\n    \"resetPassword\",                                                                               // 645\n    arguments,                                                                                     // 646\n    \"password\",                                                                                    // 647\n    function () {                                                                                  // 648\n      check(token, String);                                                                        // 649\n      check(newPassword, passwordValidator);                                                       // 650\n                                                                                                   // 651\n      var user = Meteor.users.findOne({                                                            // 652\n        \"services.password.reset.token\": token});                                                  // 653\n      if (!user)                                                                                   // 654\n        throw new Meteor.Error(403, \"Token expired\");                                              // 655\n      var email = user.services.password.reset.email;                                              // 656\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))                                // 657\n        return {                                                                                   // 658\n          userId: user._id,                                                                        // 659\n          error: new Meteor.Error(403, \"Token has invalid email address\")                          // 660\n        };                                                                                         // 661\n                                                                                                   // 662\n      var hashed = hashPassword(newPassword);                                                      // 663\n                                                                                                   // 664\n      // NOTE: We're about to invalidate tokens on the user, who we might be                       // 665\n      // logged in as. Make sure to avoid logging ourselves out if this                            // 666\n      // happens. But also make sure not to leave the connection in a state                        // 667\n      // of having a bad token set if things fail.                                                 // 668\n      var oldToken = Accounts._getLoginToken(self.connection.id);                                  // 669\n      Accounts._setLoginToken(user._id, self.connection, null);                                    // 670\n      var resetToOldToken = function () {                                                          // 671\n        Accounts._setLoginToken(user._id, self.connection, oldToken);                              // 672\n      };                                                                                           // 673\n                                                                                                   // 674\n      try {                                                                                        // 675\n        // Update the user record by:                                                              // 676\n        // - Changing the password to the new one                                                  // 677\n        // - Forgetting about the reset token that was just used                                   // 678\n        // - Verifying their email, since they got the password reset via email.                   // 679\n        var affectedRecords = Meteor.users.update(                                                 // 680\n          {                                                                                        // 681\n            _id: user._id,                                                                         // 682\n            'emails.address': email,                                                               // 683\n            'services.password.reset.token': token                                                 // 684\n          },                                                                                       // 685\n          {$set: {'services.password.bcrypt': hashed,                                              // 686\n                  'emails.$.verified': true},                                                      // 687\n           $unset: {'services.password.reset': 1,                                                  // 688\n                    'services.password.srp': 1}});                                                 // 689\n        if (affectedRecords !== 1)                                                                 // 690\n          return {                                                                                 // 691\n            userId: user._id,                                                                      // 692\n            error: new Meteor.Error(403, \"Invalid email\")                                          // 693\n          };                                                                                       // 694\n      } catch (err) {                                                                              // 695\n        resetToOldToken();                                                                         // 696\n        throw err;                                                                                 // 697\n      }                                                                                            // 698\n                                                                                                   // 699\n      // Replace all valid login tokens with new ones (changing                                    // 700\n      // password should invalidate existing sessions).                                            // 701\n      Accounts._clearAllLoginTokens(user._id);                                                     // 702\n                                                                                                   // 703\n      return {userId: user._id};                                                                   // 704\n    }                                                                                              // 705\n  );                                                                                               // 706\n}});                                                                                               // 707\n                                                                                                   // 708\n///                                                                                                // 709\n/// EMAIL VERIFICATION                                                                             // 710\n///                                                                                                // 711\n                                                                                                   // 712\n                                                                                                   // 713\n// send the user an email with a link that when opened marks that                                  // 714\n// address as verified                                                                             // 715\n                                                                                                   // 716\n/**                                                                                                // 717\n * @summary Send an email with a link the user can use verify their email address.                 // 718\n * @locus Server                                                                                   // 719\n * @param {String} userId The id of the user to send email to.                                     // 720\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n */                                                                                                // 722\nAccounts.sendVerificationEmail = function (userId, address) {                                      // 723\n  // XXX Also generate a link using which someone can delete this                                  // 724\n  // account if they own said address but weren't those who created                                // 725\n  // this account.                                                                                 // 726\n                                                                                                   // 727\n  // Make sure the user exists, and address is one of their addresses.                             // 728\n  var user = Meteor.users.findOne(userId);                                                         // 729\n  if (!user)                                                                                       // 730\n    throw new Error(\"Can't find user\");                                                            // 731\n  // pick the first unverified address if we weren't passed an address.                            // 732\n  if (!address) {                                                                                  // 733\n    var email = _.find(user.emails || [],                                                          // 734\n                       function (e) { return !e.verified; });                                      // 735\n    address = (email || {}).address;                                                               // 736\n  }                                                                                                // 737\n  // make sure we have a valid address                                                             // 738\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address))                     // 739\n    throw new Error(\"No such email address for user.\");                                            // 740\n                                                                                                   // 741\n                                                                                                   // 742\n  var tokenRecord = {                                                                              // 743\n    token: Random.secret(),                                                                        // 744\n    address: address,                                                                              // 745\n    when: new Date()};                                                                             // 746\n  Meteor.users.update(                                                                             // 747\n    {_id: userId},                                                                                 // 748\n    {$push: {'services.email.verificationTokens': tokenRecord}});                                  // 749\n                                                                                                   // 750\n  // before passing to template, update user object with new token                                 // 751\n  Meteor._ensure(user, 'services', 'email');                                                       // 752\n  if (!user.services.email.verificationTokens) {                                                   // 753\n    user.services.email.verificationTokens = [];                                                   // 754\n  }                                                                                                // 755\n  user.services.email.verificationTokens.push(tokenRecord);                                        // 756\n                                                                                                   // 757\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);                               // 758\n                                                                                                   // 759\n  var options = {                                                                                  // 760\n    to: address,                                                                                   // 761\n    from: Accounts.emailTemplates.verifyEmail.from                                                 // 762\n      ? Accounts.emailTemplates.verifyEmail.from(user)                                             // 763\n      : Accounts.emailTemplates.from,                                                              // 764\n    subject: Accounts.emailTemplates.verifyEmail.subject(user)                                     // 765\n  };                                                                                               // 766\n                                                                                                   // 767\n  if (typeof Accounts.emailTemplates.verifyEmail.text === 'function') {                            // 768\n    options.text =                                                                                 // 769\n      Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl);                              // 770\n  }                                                                                                // 771\n                                                                                                   // 772\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function')                              // 773\n    options.html =                                                                                 // 774\n      Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);                              // 775\n                                                                                                   // 776\n  if (typeof Accounts.emailTemplates.headers === 'object') {                                       // 777\n    options.headers = Accounts.emailTemplates.headers;                                             // 778\n  }                                                                                                // 779\n                                                                                                   // 780\n  Email.send(options);                                                                             // 781\n};                                                                                                 // 782\n                                                                                                   // 783\n// Take token from sendVerificationEmail, mark the email as verified,                              // 784\n// and log them in.                                                                                // 785\nMeteor.methods({verifyEmail: function (token) {                                                    // 786\n  var self = this;                                                                                 // 787\n  return Accounts._loginMethod(                                                                    // 788\n    self,                                                                                          // 789\n    \"verifyEmail\",                                                                                 // 790\n    arguments,                                                                                     // 791\n    \"password\",                                                                                    // 792\n    function () {                                                                                  // 793\n      check(token, String);                                                                        // 794\n                                                                                                   // 795\n      var user = Meteor.users.findOne(                                                             // 796\n        {'services.email.verificationTokens.token': token});                                       // 797\n      if (!user)                                                                                   // 798\n        throw new Meteor.Error(403, \"Verify email link expired\");                                  // 799\n                                                                                                   // 800\n      var tokenRecord = _.find(user.services.email.verificationTokens,                             // 801\n                               function (t) {                                                      // 802\n                                 return t.token == token;                                          // 803\n                               });                                                                 // 804\n      if (!tokenRecord)                                                                            // 805\n        return {                                                                                   // 806\n          userId: user._id,                                                                        // 807\n          error: new Meteor.Error(403, \"Verify email link expired\")                                // 808\n        };                                                                                         // 809\n                                                                                                   // 810\n      var emailsRecord = _.find(user.emails, function (e) {                                        // 811\n        return e.address == tokenRecord.address;                                                   // 812\n      });                                                                                          // 813\n      if (!emailsRecord)                                                                           // 814\n        return {                                                                                   // 815\n          userId: user._id,                                                                        // 816\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")                 // 817\n        };                                                                                         // 818\n                                                                                                   // 819\n      // By including the address in the query, we can use 'emails.$' in the                       // 820\n      // modifier to get a reference to the specific object in the emails                          // 821\n      // array. See                                                                                // 822\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)          // 823\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull                             // 824\n      Meteor.users.update(                                                                         // 825\n        {_id: user._id,                                                                            // 826\n         'emails.address': tokenRecord.address},                                                   // 827\n        {$set: {'emails.$.verified': true},                                                        // 828\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});           // 829\n                                                                                                   // 830\n      return {userId: user._id};                                                                   // 831\n    }                                                                                              // 832\n  );                                                                                               // 833\n}});                                                                                               // 834\n                                                                                                   // 835\n/**                                                                                                // 836\n * @summary Add an email address for a user. Use this instead of directly                          // 837\n * updating the database. The operation will fail if there is a different user                     // 838\n * with an email only differing in case. If the specified user has an existing                     // 839\n * email only differing in case however, we replace it.                                            // 840\n * @locus Server                                                                                   // 841\n * @param {String} userId The ID of the user to update.                                            // 842\n * @param {String} newEmail A new email address for the user.                                      // 843\n * @param {Boolean} [verified] Optional - whether the new email address should                     // 844\n * be marked as verified. Defaults to false.                                                       // 845\n */                                                                                                // 846\nAccounts.addEmail = function (userId, newEmail, verified) {                                        // 847\n  check(userId, NonEmptyString);                                                                   // 848\n  check(newEmail, NonEmptyString);                                                                 // 849\n  check(verified, Match.Optional(Boolean));                                                        // 850\n                                                                                                   // 851\n  if (_.isUndefined(verified)) {                                                                   // 852\n    verified = false;                                                                              // 853\n  }                                                                                                // 854\n                                                                                                   // 855\n  var user = Meteor.users.findOne(userId);                                                         // 856\n  if (!user)                                                                                       // 857\n    throw new Meteor.Error(403, \"User not found\");                                                 // 858\n                                                                                                   // 859\n  // Allow users to change their own email to a version with a different case                      // 860\n                                                                                                   // 861\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case                          // 862\n  // insensitive check across all emails in the database here because: (1) if                      // 863\n  // there is no case-insensitive duplicate between this user and other users,                     // 864\n  // then we are OK and (2) if this would create a conflict with other users                       // 865\n  // then there would already be a case-insensitive duplicate and we can't fix                     // 866\n  // that in this code anyway.                                                                     // 867\n  var caseInsensitiveRegExp =                                                                      // 868\n    new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');                                   // 869\n                                                                                                   // 870\n  var didUpdateOwnEmail = _.any(user.emails, function(email, index) {                              // 871\n    if (caseInsensitiveRegExp.test(email.address)) {                                               // 872\n      Meteor.users.update({                                                                        // 873\n        _id: user._id,                                                                             // 874\n        'emails.address': email.address                                                            // 875\n      }, {$set: {                                                                                  // 876\n        'emails.$.address': newEmail,                                                              // 877\n        'emails.$.verified': verified                                                              // 878\n      }});                                                                                         // 879\n      return true;                                                                                 // 880\n    }                                                                                              // 881\n                                                                                                   // 882\n    return false;                                                                                  // 883\n  });                                                                                              // 884\n                                                                                                   // 885\n  // In the other updates below, we have to do another call to                                     // 886\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values                     // 887\n  // were added to the database in the meantime. We don't have to do this for                      // 888\n  // the case where the user is updating their email address to one that is the                    // 889\n  // same as before, but only different because of capitalization. Read the                        // 890\n  // big comment above to understand why.                                                          // 891\n                                                                                                   // 892\n  if (didUpdateOwnEmail) {                                                                         // 893\n    return;                                                                                        // 894\n  }                                                                                                // 895\n                                                                                                   // 896\n  // Perform a case insensitive check for duplicates before update                                 // 897\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);                // 898\n                                                                                                   // 899\n  Meteor.users.update({                                                                            // 900\n    _id: user._id                                                                                  // 901\n  }, {                                                                                             // 902\n    $addToSet: {                                                                                   // 903\n      emails: {                                                                                    // 904\n        address: newEmail,                                                                         // 905\n        verified: verified                                                                         // 906\n      }                                                                                            // 907\n    }                                                                                              // 908\n  });                                                                                              // 909\n                                                                                                   // 910\n  // Perform another check after update, in case a matching user has been                          // 911\n  // inserted in the meantime                                                                      // 912\n  try {                                                                                            // 913\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);              // 914\n  } catch (ex) {                                                                                   // 915\n    // Undo update if the check fails                                                              // 916\n    Meteor.users.update({_id: user._id},                                                           // 917\n      {$pull: {emails: {address: newEmail}}});                                                     // 918\n    throw ex;                                                                                      // 919\n  }                                                                                                // 920\n}                                                                                                  // 921\n                                                                                                   // 922\n/**                                                                                                // 923\n * @summary Remove an email address for a user. Use this instead of updating                       // 924\n * the database directly.                                                                          // 925\n * @locus Server                                                                                   // 926\n * @param {String} userId The ID of the user to update.                                            // 927\n * @param {String} email The email address to remove.                                              // 928\n */                                                                                                // 929\nAccounts.removeEmail = function (userId, email) {                                                  // 930\n  check(userId, NonEmptyString);                                                                   // 931\n  check(email, NonEmptyString);                                                                    // 932\n                                                                                                   // 933\n  var user = Meteor.users.findOne(userId);                                                         // 934\n  if (!user)                                                                                       // 935\n    throw new Meteor.Error(403, \"User not found\");                                                 // 936\n                                                                                                   // 937\n  Meteor.users.update({_id: user._id},                                                             // 938\n    {$pull: {emails: {address: email}}});                                                          // 939\n}                                                                                                  // 940\n                                                                                                   // 941\n///                                                                                                // 942\n/// CREATING USERS                                                                                 // 943\n///                                                                                                // 944\n                                                                                                   // 945\n// Shared createUser function called from the createUser method, both                              // 946\n// if originates in client or server code. Calls user provided hooks,                              // 947\n// does the actual user insertion.                                                                 // 948\n//                                                                                                 // 949\n// returns the user id                                                                             // 950\nvar createUser = function (options) {                                                              // 951\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary                           // 952\n  // options.                                                                                      // 953\n  check(options, Match.ObjectIncluding({                                                           // 954\n    username: Match.Optional(String),                                                              // 955\n    email: Match.Optional(String),                                                                 // 956\n    password: Match.Optional(passwordValidator)                                                    // 957\n  }));                                                                                             // 958\n                                                                                                   // 959\n  var username = options.username;                                                                 // 960\n  var email = options.email;                                                                       // 961\n  if (!username && !email)                                                                         // 962\n    throw new Meteor.Error(400, \"Need to set a username or email\");                                // 963\n                                                                                                   // 964\n  var user = {services: {}};                                                                       // 965\n  if (options.password) {                                                                          // 966\n    var hashed = hashPassword(options.password);                                                   // 967\n    user.services.password = { bcrypt: hashed };                                                   // 968\n  }                                                                                                // 969\n                                                                                                   // 970\n  if (username)                                                                                    // 971\n    user.username = username;                                                                      // 972\n  if (email)                                                                                       // 973\n    user.emails = [{address: email, verified: false}];                                             // 974\n                                                                                                   // 975\n  // Perform a case insensitive check before insert                                                // 976\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);                             // 977\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);                             // 978\n                                                                                                   // 979\n  var userId = Accounts.insertUserDoc(options, user);                                              // 980\n  // Perform another check after insert, in case a matching user has been                          // 981\n  // inserted in the meantime                                                                      // 982\n  try {                                                                                            // 983\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);                   // 984\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);                   // 985\n  } catch (ex) {                                                                                   // 986\n    // Remove inserted user if the check fails                                                     // 987\n    Meteor.users.remove(userId);                                                                   // 988\n    throw ex;                                                                                      // 989\n  }                                                                                                // 990\n  return userId;                                                                                   // 991\n};                                                                                                 // 992\n                                                                                                   // 993\n// method for create user. Requests come from the client.                                          // 994\nMeteor.methods({createUser: function (options) {                                                   // 995\n  var self = this;                                                                                 // 996\n  return Accounts._loginMethod(                                                                    // 997\n    self,                                                                                          // 998\n    \"createUser\",                                                                                  // 999\n    arguments,                                                                                     // 1000\n    \"password\",                                                                                    // 1001\n    function () {                                                                                  // 1002\n      // createUser() above does more checking.                                                    // 1003\n      check(options, Object);                                                                      // 1004\n      if (Accounts._options.forbidClientAccountCreation)                                           // 1005\n        return {                                                                                   // 1006\n          error: new Meteor.Error(403, \"Signups forbidden\")                                        // 1007\n        };                                                                                         // 1008\n                                                                                                   // 1009\n      // Create user. result contains id and token.                                                // 1010\n      var userId = createUser(options);                                                            // 1011\n      // safety belt. createUser is supposed to throw on error. send 500 error                     // 1012\n      // instead of sending a verification email with empty userid.                                // 1013\n      if (! userId)                                                                                // 1014\n        throw new Error(\"createUser failed to insert new user\");                                   // 1015\n                                                                                                   // 1016\n      // If `Accounts._options.sendVerificationEmail` is set, register                             // 1017\n      // a token to verify the user's primary email, and send it to                                // 1018\n      // that address.                                                                             // 1019\n      if (options.email && Accounts._options.sendVerificationEmail)                                // 1020\n        Accounts.sendVerificationEmail(userId, options.email);                                     // 1021\n                                                                                                   // 1022\n      // client gets logged in as the new user afterwards.                                         // 1023\n      return {userId: userId};                                                                     // 1024\n    }                                                                                              // 1025\n  );                                                                                               // 1026\n}});                                                                                               // 1027\n                                                                                                   // 1028\n// Create user directly on the server.                                                             // 1029\n//                                                                                                 // 1030\n// Unlike the client version, this does not log you in as this user                                // 1031\n// after creation.                                                                                 // 1032\n//                                                                                                 // 1033\n// returns userId or throws an error if it can't create                                            // 1034\n//                                                                                                 // 1035\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,                     // 1036\n// which is always empty when called from the createUser method? eg, \"admin:                       // 1037\n// true\", which we want to prevent the client from setting, but which a custom                     // 1038\n// method calling Accounts.createUser could set?                                                   // 1039\n//                                                                                                 // 1040\nAccounts.createUser = function (options, callback) {                                               // 1041\n  options = _.clone(options);                                                                      // 1042\n                                                                                                   // 1043\n  // XXX allow an optional callback?                                                               // 1044\n  if (callback) {                                                                                  // 1045\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");         // 1046\n  }                                                                                                // 1047\n                                                                                                   // 1048\n  return createUser(options);                                                                      // 1049\n};                                                                                                 // 1050\n                                                                                                   // 1051\n///                                                                                                // 1052\n/// PASSWORD-SPECIFIC INDEXES ON USERS                                                             // 1053\n///                                                                                                // 1054\nMeteor.users._ensureIndex('services.email.verificationTokens.token',                               // 1055\n                          {unique: 1, sparse: 1});                                                 // 1056\nMeteor.users._ensureIndex('services.password.reset.token',                                         // 1057\n                          {unique: 1, sparse: 1});                                                 // 1058\n                                                                                                   // 1059\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['accounts-password'] = {};\n\n})();\n","servePath":"/packages/accounts-password.js","sourceMap":{"version":3,"sources":["/packages/accounts-password/email_templates.js","/packages/accounts-password/password_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wG;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0G","file":"/packages/accounts-password.js","sourcesContent":["/**\n * @summary Options to customize emails sent from the Accounts system.\n * @locus Server\n */\nAccounts.emailTemplates = {\n  from: \"Meteor Accounts <no-reply@meteor.com>\",\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\n\n  resetPassword: {\n    subject: function(user) {\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return greeting + \"\\n\"\n        + \"\\n\"\n        + \"To reset your password, simply click the link below.\\n\"\n        + \"\\n\"\n        + url + \"\\n\"\n        + \"\\n\"\n        + \"Thanks.\\n\";\n    }\n  },\n  verifyEmail: {\n    subject: function(user) {\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return greeting + \"\\n\"\n        + \"\\n\"\n        + \"To verify your account email, simply click the link below.\\n\"\n        + \"\\n\"\n        + url + \"\\n\"\n        + \"\\n\"\n        + \"Thanks.\\n\";\n    }\n  },\n  enrollAccount: {\n    subject: function(user) {\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;\n    },\n    text: function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return greeting + \"\\n\"\n        + \"\\n\"\n        + \"To start using the service, simply click the link below.\\n\"\n        + \"\\n\"\n        + url + \"\\n\"\n        + \"\\n\"\n        + \"Thanks.\\n\";\n    }\n  }\n};\n","/// BCRYPT\n\nvar bcrypt = NpmModuleBcrypt;\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nvar getPasswordString = function (password) {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nvar hashPassword = function (password) {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds);\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\nAccounts._checkPassword = function (user, password) {\n  var result = {\n    userId: user._id\n  };\n\n  password = getPasswordString(password);\n\n  if (! bcryptCompare(password, user.services.password.bcrypt)) {\n    result.error = new Meteor.Error(403, \"Incorrect password\");\n  }\n\n  return result;\n};\nvar checkPassword = Accounts._checkPassword;\n\n///\n/// LOGIN\n///\n\nAccounts._findUserByQuery = function (query) {\n  var user = null;\n\n  if (query.id) {\n    user = Meteor.users.findOne({ _id: query.id });\n  } else {\n    var fieldName;\n    var fieldValue;\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n    var selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector);\n    // If user is not found, try a case insensitive lookup\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      var candidateUsers = Meteor.users.find(selector).fetch();\n      // No match if multiple candidates are found\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @returns {Object} A user if found, else null\n */\nAccounts.findUserByUsername = function (username) {\n  return Accounts._findUserByQuery({\n    username: username\n  });\n};\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @returns {Object} A user if found, else null\n */\nAccounts.findUserByEmail = function (email) {\n  return Accounts._findUserByQuery({\n    email: email\n  });\n};\n\n// Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {\n  // Performance seems to improve up to 4 prefix characters\n  var prefix = string.substring(0, Math.min(string.length, 4));\n  var orClause = _.map(generateCasePermutationsForString(prefix),\n    function (prefixPermutation) {\n      var selector = {};\n      selector[fieldName] =\n        new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));\n      return selector;\n    });\n  var caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] =\n    new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i')\n  return {$and: [{$or: orClause}, caseInsensitiveClause]};\n}\n\n// Generates permutations of all case variations of a given string.\nvar generateCasePermutationsForString = function (string) {\n  var permutations = [''];\n  for (var i = 0; i < string.length; i++) {\n    var ch = string.charAt(i);\n    permutations = _.flatten(_.map(permutations, function (prefix) {\n      var lowerCaseChar = ch.toLowerCase();\n      var upperCaseChar = ch.toUpperCase();\n      // Don't add unneccesary permutations when ch is not a letter\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n  return permutations;\n}\n\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    var matchedUsers = Meteor.users.find(\n      selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();\n\n    if (matchedUsers.length > 0 &&\n        // If we don't have a userId yet, any match we find is a duplicate\n        (!ownUserId ||\n        // Otherwise, check to see if there are multiple matches or a match\n        // that is not us\n        (matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {\n      throw new Meteor.Error(403, displayName + \" already exists.\");\n    }\n  }\n};\n\n// XXX maybe this belongs in the check package\nvar NonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n});\n\nvar userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (_.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nvar passwordValidator = Match.OneOf(\n  String,\n  { digest: String, algorithm: String }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (! options.password || options.srp)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n      !(user.services.password.bcrypt || user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      var verifier = user.services.password.srp;\n      var newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity, salt: verifier.salt});\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Incorrect password\")\n        };\n      }\n\n      return {userId: user._id};\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(\n    user,\n    options.password\n  );\n});\n\n// Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.srp || !options.password)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n  if (user.services && user.services.password && user.services.password.bcrypt)\n    return checkPassword(user, options.password);\n\n  if (!(user.services && user.services.password && user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  var v1 = user.services.password.srp.verifier;\n  var v2 = SRP.generateVerifier(\n    null,\n    {\n      hashedIdentityAndPassword: options.srp,\n      salt: user.services.password.srp.salt\n    }\n  ).verifier;\n  if (v1 !== v2)\n    return {\n      userId: user._id,\n      error: new Meteor.Error(403, \"Incorrect password\")\n    };\n\n  // Upgrade to bcrypt on successful login.\n  var salted = hashPassword(options.password);\n  Meteor.users.update(\n    user._id,\n    {\n      $unset: { 'services.password.srp': 1 },\n      $set: { 'services.password.bcrypt': salted }\n    }\n  );\n\n  return {userId: user._id};\n});\n\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n */\nAccounts.setUsername = function (userId, newUsername) {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  var oldUsername = user.username;\n\n  // Perform a case insensitive check fro duplicates before update\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\nMeteor.methods({changePassword: function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId)\n    throw new Meteor.Error(401, \"Must be logged in\");\n\n  var user = Meteor.users.findOne(this.userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  if (!user.services || !user.services.password ||\n      (!user.services.password.bcrypt && !user.services.password.srp))\n    throw new Meteor.Error(403, \"User has no password set\");\n\n  if (! user.services.password.bcrypt) {\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n      format: 'srp',\n      identity: user.services.password.srp.identity\n    }));\n  }\n\n  var result = checkPassword(user, oldPassword);\n  if (result.error)\n    throw result.error;\n\n  var hashed = hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  var currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n */\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {\n  options = _.extend({logout: true}, options);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  var update = {\n    $unset: {\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: function (options) {\n  check(options, {email: String});\n\n  var user = Meteor.users.findOne({\"emails.address\": options.email});\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Accounts.sendResetPasswordEmail(user._id, options.email);\n}});\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */\nAccounts.sendResetPasswordEmail = function (userId, email) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var resetPasswordUrl = Accounts.urls.resetPassword(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.resetPassword.from\n      ? Accounts.emailTemplates.resetPassword.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.resetPassword.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.resetPassword.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.resetPassword.text(user, resetPasswordUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.resetPassword.html === 'function')\n    options.html =\n      Accounts.emailTemplates.resetPassword.html(user, resetPasswordUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n */\nAccounts.sendEnrollmentEmail = function (userId, email) {\n  // XXX refactor! This is basically identical to sendResetPasswordEmail.\n\n  // Make sure the user exists, and email is in their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0])\n    email = user.emails[0].address;\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email))\n    throw new Error(\"No such email for user.\");\n\n  var token = Random.secret();\n  var when = new Date();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: when\n  };\n  Meteor.users.update(userId, {$set: {\n    \"services.password.reset\": tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  var enrollAccountUrl = Accounts.urls.enrollAccount(token);\n\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates.enrollAccount.from\n      ? Accounts.emailTemplates.enrollAccount.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.enrollAccount.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.enrollAccount.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.enrollAccount.text(user, enrollAccountUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.enrollAccount.html === 'function')\n    options.html =\n      Accounts.emailTemplates.enrollAccount.html(user, enrollAccountUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: function (token, newPassword) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"resetPassword\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      var user = Meteor.users.findOne({\n        \"services.password.reset.token\": token});\n      if (!user)\n        throw new Meteor.Error(403, \"Token expired\");\n      var email = user.services.password.reset.email;\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      var hashed = hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      var oldToken = Accounts._getLoginToken(self.connection.id);\n      Accounts._setLoginToken(user._id, self.connection, null);\n      var resetToOldToken = function () {\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\n      };\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        var affectedRecords = Meteor.users.update(\n          {\n            _id: user._id,\n            'emails.address': email,\n            'services.password.reset.token': token\n          },\n          {$set: {'services.password.bcrypt': hashed,\n                  'emails.$.verified': true},\n           $unset: {'services.password.reset': 1,\n                    'services.password.srp': 1}});\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n */\nAccounts.sendVerificationEmail = function (userId, address) {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  // Make sure the user exists, and address is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Error(\"Can't find user\");\n  // pick the first unverified address if we weren't passed an address.\n  if (!address) {\n    var email = _.find(user.emails || [],\n                       function (e) { return !e.verified; });\n    address = (email || {}).address;\n  }\n  // make sure we have a valid address\n  if (!address || !_.contains(_.pluck(user.emails || [], 'address'), address))\n    throw new Error(\"No such email address for user.\");\n\n\n  var tokenRecord = {\n    token: Random.secret(),\n    address: address,\n    when: new Date()};\n  Meteor.users.update(\n    {_id: userId},\n    {$push: {'services.email.verificationTokens': tokenRecord}});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  var verifyEmailUrl = Accounts.urls.verifyEmail(tokenRecord.token);\n\n  var options = {\n    to: address,\n    from: Accounts.emailTemplates.verifyEmail.from\n      ? Accounts.emailTemplates.verifyEmail.from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates.verifyEmail.subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates.verifyEmail.text === 'function') {\n    options.text =\n      Accounts.emailTemplates.verifyEmail.text(user, verifyEmailUrl);\n  }\n\n  if (typeof Accounts.emailTemplates.verifyEmail.html === 'function')\n    options.html =\n      Accounts.emailTemplates.verifyEmail.html(user, verifyEmailUrl);\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  Email.send(options);\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: function (token) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"verifyEmail\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n\n      var user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token});\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n      var tokenRecord = _.find(user.services.email.verificationTokens,\n                               function (t) {\n                                 return t.token == token;\n                               });\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      var emailsRecord = _.find(user.emails, function (e) {\n        return e.address == tokenRecord.address;\n      });\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n */\nAccounts.addEmail = function (userId, newEmail, verified) {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (_.isUndefined(verified)) {\n    verified = false;\n  }\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  var caseInsensitiveRegExp =\n    new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');\n\n  var didUpdateOwnEmail = _.any(user.emails, function(email, index) {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {$set: {\n        'emails.$.address': newEmail,\n        'emails.$.verified': verified\n      }});\n      return true;\n    }\n\n    return false;\n  });\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id},\n      {$pull: {emails: {address: newEmail}}});\n    throw ex;\n  }\n}\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n */\nAccounts.removeEmail = function (userId, email) {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Meteor.users.update({_id: user._id},\n    {$pull: {emails: {address: email}}});\n}\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nvar createUser = function (options) {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  var username = options.username;\n  var email = options.email;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  var user = {services: {}};\n  if (options.password) {\n    var hashed = hashPassword(options.password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  if (username)\n    user.username = username;\n  if (email)\n    user.emails = [{address: email, verified: false}];\n\n  // Perform a case insensitive check before insert\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n  var userId = Accounts.insertUserDoc(options, user);\n  // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n  return userId;\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: function (options) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"createUser\",\n    arguments,\n    \"password\",\n    function () {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      // Create user. result contains id and token.\n      var userId = createUser(options);\n      // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n      if (! userId)\n        throw new Error(\"createUser failed to insert new user\");\n\n      // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n      if (options.email && Accounts._options.sendVerificationEmail)\n        Accounts.sendVerificationEmail(userId, options.email);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options);\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users._ensureIndex('services.email.verificationTokens.token',\n                          {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.password.reset.token',\n                          {unique: 1, sparse: 1});\n"]}}]