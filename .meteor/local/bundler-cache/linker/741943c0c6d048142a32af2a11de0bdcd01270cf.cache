[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar HTTP = Package.http.HTTP;\n\n/* Package-scope variables */\nvar TimeSync, SyncInternals;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                      //\n// packages/mizzao_timesync/packages/mizzao_timesync.js                                 //\n//                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////\n                                                                                        //\n(function () {                                                                          // 1\n                                                                                        // 2\n///////////////////////////////////////////////////////////////////////////////////     // 3\n//                                                                               //     // 4\n// packages/mizzao:timesync/timesync-client.js                                   //     // 5\n//                                                                               //     // 6\n///////////////////////////////////////////////////////////////////////////////////     // 7\n                                                                                 //     // 8\n//IE8 doesn't have Date.now()                                                    // 1   // 9\nDate.now = Date.now || function() { return +new Date; };                         // 2   // 10\n                                                                                 // 3   // 11\nTimeSync = {                                                                     // 4   // 12\n  loggingEnabled: true                                                           // 5   // 13\n};                                                                               // 6   // 14\n                                                                                 // 7   // 15\nfunction log(/* arguments */) {                                                  // 8   // 16\n  if (TimeSync.loggingEnabled) {                                                 // 9   // 17\n    Meteor._debug.apply(this, arguments);                                        // 10  // 18\n  }                                                                              // 11  // 19\n}                                                                                // 12  // 20\n                                                                                 // 13  // 21\nvar defaultInterval = 1000;                                                      // 14  // 22\n                                                                                 // 15  // 23\n// Internal values, exported for testing                                         // 16  // 24\nSyncInternals = {                                                                // 17  // 25\n  offset: undefined,                                                             // 18  // 26\n  roundTripTime: undefined,                                                      // 19  // 27\n  offsetDep: new Deps.Dependency(),                                              // 20  // 28\n  timeTick: {},                                                                  // 21  // 29\n                                                                                 // 22  // 30\n  timeCheck: function (lastTime, currentTime, interval, tolerance) {             // 23  // 31\n    if (Math.abs(currentTime - lastTime - interval) < tolerance) {               // 24  // 32\n      // Everything is A-OK                                                      // 25  // 33\n      return true;                                                               // 26  // 34\n    }                                                                            // 27  // 35\n    // We're no longer in sync.                                                  // 28  // 36\n    return false;                                                                // 29  // 37\n  }                                                                              // 30  // 38\n};                                                                               // 31  // 39\n                                                                                 // 32  // 40\nSyncInternals.timeTick[defaultInterval] = new Deps.Dependency();                 // 33  // 41\n                                                                                 // 34  // 42\nvar maxAttempts = 5;                                                             // 35  // 43\nvar attempts = 0;                                                                // 36  // 44\n                                                                                 // 37  // 45\n/*                                                                               // 38  // 46\n  This is an approximation of                                                    // 39  // 47\n  http://en.wikipedia.org/wiki/Network_Time_Protocol                             // 40  // 48\n                                                                                 // 41  // 49\n  If this turns out to be more accurate under the connect handlers,              // 42  // 50\n  we should try taking multiple measurements.                                    // 43  // 51\n */                                                                              // 44  // 52\n                                                                                 // 45  // 53\n// Only use Meteor.absoluteUrl for Cordova; see                                  // 46  // 54\n// https://github.com/meteor/meteor/issues/4696                                  // 47  // 55\n// https://github.com/mizzao/meteor-timesync/issues/30                           // 48  // 56\nvar syncUrl = \"/_timesync\";                                                      // 49  // 57\nif (Meteor.isCordova) {                                                          // 50  // 58\n  syncUrl = Meteor.absoluteUrl(\"_timesync\");                                     // 51  // 59\n}                                                                                // 52  // 60\n                                                                                 // 53  // 61\nvar updateOffset = function() {                                                  // 54  // 62\n  var t0 = Date.now();                                                           // 55  // 63\n                                                                                 // 56  // 64\n  HTTP.get(syncUrl, function(err, response) {                                    // 57  // 65\n    var t3 = Date.now(); // Grab this now                                        // 58  // 66\n    if (err) {                                                                   // 59  // 67\n      //  We'll still use our last computed offset if is defined                 // 60  // 68\n      log(\"Error syncing to server time: \", err);                                // 61  // 69\n      if (++attempts <= maxAttempts)                                             // 62  // 70\n        Meteor.setTimeout(TimeSync.resync, 1000);                                // 63  // 71\n      else                                                                       // 64  // 72\n        log(\"Max number of time sync attempts reached. Giving up.\");             // 65  // 73\n      return;                                                                    // 66  // 74\n    }                                                                            // 67  // 75\n                                                                                 // 68  // 76\n    attempts = 0; // It worked                                                   // 69  // 77\n                                                                                 // 70  // 78\n    var ts = parseInt(response.content);                                         // 71  // 79\n    SyncInternals.offset = Math.round(((ts - t0) + (ts - t3)) / 2);              // 72  // 80\n    SyncInternals.roundTripTime = t3 - t0; // - (ts - ts) which is 0             // 73  // 81\n    SyncInternals.offsetDep.changed();                                           // 74  // 82\n  });                                                                            // 75  // 83\n};                                                                               // 76  // 84\n                                                                                 // 77  // 85\n// Reactive variable for server time that updates every second.                  // 78  // 86\nTimeSync.serverTime = function(clientTime, interval) {                           // 79  // 87\n  check(interval, Match.Optional(Match.Integer));                                // 80  // 88\n  // If we don't know the offset, we can't provide the server time.              // 81  // 89\n  if ( !TimeSync.isSynced() ) return undefined;                                  // 82  // 90\n  // If a client time is provided, we don't need to depend on the tick.          // 83  // 91\n  if ( !clientTime ) getTickDependency(interval || defaultInterval).depend();    // 84  // 92\n                                                                                 // 85  // 93\n  // SyncInternals.offsetDep.depend(); implicit as we call isSynced()            // 86  // 94\n  // Convert Date argument to epoch as necessary                                 // 87  // 95\n  return (+clientTime || Date.now()) + SyncInternals.offset;                     // 88  // 96\n};                                                                               // 89  // 97\n                                                                                 // 90  // 98\n// Reactive variable for the difference between server and client time.          // 91  // 99\nTimeSync.serverOffset = function() {                                             // 92  // 100\n  SyncInternals.offsetDep.depend();                                              // 93  // 101\n  return SyncInternals.offset;                                                   // 94  // 102\n};                                                                               // 95  // 103\n                                                                                 // 96  // 104\nTimeSync.roundTripTime = function() {                                            // 97  // 105\n  SyncInternals.offsetDep.depend();                                              // 98  // 106\n  return SyncInternals.roundTripTime;                                            // 99  // 107\n};                                                                               // 100\n                                                                                 // 101\nTimeSync.isSynced = function() {                                                 // 102\n  SyncInternals.offsetDep.depend();                                              // 103\n  return SyncInternals.offset !== undefined;                                     // 104\n};                                                                               // 105\n                                                                                 // 106\nvar resyncIntervalId = null;                                                     // 107\n                                                                                 // 108\nTimeSync.resync = function() {                                                   // 109\n  if (resyncIntervalId !== null) Meteor.clearInterval(resyncIntervalId);         // 110\n  updateOffset();                                                                // 111\n  resyncIntervalId = Meteor.setInterval(updateOffset, 600000);                   // 112\n};                                                                               // 113\n                                                                                 // 114\n// Run this as soon as we load, even before Meteor.startup()                     // 115\n// Run again whenever we reconnect after losing connection                       // 116\nvar wasConnected = false;                                                        // 117\n                                                                                 // 118\nDeps.autorun(function() {                                                        // 119\n  var connected = Meteor.status().connected;                                     // 120\n  if ( connected && !wasConnected ) TimeSync.resync();                           // 121\n  wasConnected = connected;                                                      // 122\n});                                                                              // 123\n                                                                                 // 124\n// Resync if unexpected change by more than a few seconds. This needs to be      // 125\n// somewhat lenient, or a CPU-intensive operation can trigger a re-sync even     // 126\n// when the offset is still accurate. In any case, we're not going to be able to // 127\n// catch very small system-initiated NTP adjustments with this, anyway.          // 128\nvar tickCheckTolerance = 5000;                                                   // 129\n                                                                                 // 130\nvar lastClientTime = Date.now();                                                 // 131\n                                                                                 // 132\n// Set up a new interval for any amount of reactivity.                           // 133\nfunction getTickDependency(interval) {                                           // 134\n                                                                                 // 135\n  if ( !SyncInternals.timeTick[interval] ) {                                     // 136\n    var dep  = new Deps.Dependency();                                            // 137\n                                                                                 // 138\n    Meteor.setInterval(function() {                                              // 139\n      dep.changed();                                                             // 140\n    }, interval);                                                                // 141\n                                                                                 // 142\n    SyncInternals.timeTick[interval] = dep;                                      // 143\n  }                                                                              // 144\n                                                                                 // 145\n  return SyncInternals.timeTick[interval];                                       // 146\n}                                                                                // 147\n                                                                                 // 148\n// Set up special interval for the default tick, which also watches for re-sync  // 149\nMeteor.setInterval(function() {                                                  // 150\n  var currentClientTime = Date.now();                                            // 151\n                                                                                 // 152\n  if ( SyncInternals.timeCheck(                                                  // 153\n    lastClientTime, currentClientTime, defaultInterval, tickCheckTolerance) ) {  // 154\n    // No problem here, just keep ticking along                                  // 155\n    SyncInternals.timeTick[defaultInterval].changed();                           // 156\n  }                                                                              // 157\n  else {                                                                         // 158\n    // resync on major client clock changes                                      // 159\n    // based on http://stackoverflow.com/a/3367542/1656818                       // 160\n    log(\"Clock discrepancy detected. Attempting re-sync.\");                      // 161\n    // Refuse to compute server time.                                            // 162\n    SyncInternals.offset = undefined;                                            // 163\n    SyncInternals.offsetDep.changed();                                           // 164\n    TimeSync.resync();                                                           // 165\n  }                                                                              // 166\n                                                                                 // 167\n  lastClientTime = currentClientTime;                                            // 168\n}, defaultInterval);                                                             // 169\n                                                                                 // 170\n                                                                                 // 171\n///////////////////////////////////////////////////////////////////////////////////     // 180\n                                                                                        // 181\n}).call(this);                                                                          // 182\n                                                                                        // 183\n//////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['mizzao:timesync'] = {\n  TimeSync: TimeSync,\n  SyncInternals: SyncInternals\n};\n\n})();\n","servePath":"/packages/mizzao_timesync.js","sourceMap":{"version":3,"sources":["/packages/mizzao_timesync/packages/mizzao_timesync.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8F","file":"/packages/mizzao_timesync.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/mizzao:timesync/timesync-client.js                                   //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n//IE8 doesn't have Date.now()                                                    // 1\nDate.now = Date.now || function() { return +new Date; };                         // 2\n                                                                                 // 3\nTimeSync = {                                                                     // 4\n  loggingEnabled: true                                                           // 5\n};                                                                               // 6\n                                                                                 // 7\nfunction log(/* arguments */) {                                                  // 8\n  if (TimeSync.loggingEnabled) {                                                 // 9\n    Meteor._debug.apply(this, arguments);                                        // 10\n  }                                                                              // 11\n}                                                                                // 12\n                                                                                 // 13\nvar defaultInterval = 1000;                                                      // 14\n                                                                                 // 15\n// Internal values, exported for testing                                         // 16\nSyncInternals = {                                                                // 17\n  offset: undefined,                                                             // 18\n  roundTripTime: undefined,                                                      // 19\n  offsetDep: new Deps.Dependency(),                                              // 20\n  timeTick: {},                                                                  // 21\n                                                                                 // 22\n  timeCheck: function (lastTime, currentTime, interval, tolerance) {             // 23\n    if (Math.abs(currentTime - lastTime - interval) < tolerance) {               // 24\n      // Everything is A-OK                                                      // 25\n      return true;                                                               // 26\n    }                                                                            // 27\n    // We're no longer in sync.                                                  // 28\n    return false;                                                                // 29\n  }                                                                              // 30\n};                                                                               // 31\n                                                                                 // 32\nSyncInternals.timeTick[defaultInterval] = new Deps.Dependency();                 // 33\n                                                                                 // 34\nvar maxAttempts = 5;                                                             // 35\nvar attempts = 0;                                                                // 36\n                                                                                 // 37\n/*                                                                               // 38\n  This is an approximation of                                                    // 39\n  http://en.wikipedia.org/wiki/Network_Time_Protocol                             // 40\n                                                                                 // 41\n  If this turns out to be more accurate under the connect handlers,              // 42\n  we should try taking multiple measurements.                                    // 43\n */                                                                              // 44\n                                                                                 // 45\n// Only use Meteor.absoluteUrl for Cordova; see                                  // 46\n// https://github.com/meteor/meteor/issues/4696                                  // 47\n// https://github.com/mizzao/meteor-timesync/issues/30                           // 48\nvar syncUrl = \"/_timesync\";                                                      // 49\nif (Meteor.isCordova) {                                                          // 50\n  syncUrl = Meteor.absoluteUrl(\"_timesync\");                                     // 51\n}                                                                                // 52\n                                                                                 // 53\nvar updateOffset = function() {                                                  // 54\n  var t0 = Date.now();                                                           // 55\n                                                                                 // 56\n  HTTP.get(syncUrl, function(err, response) {                                    // 57\n    var t3 = Date.now(); // Grab this now                                        // 58\n    if (err) {                                                                   // 59\n      //  We'll still use our last computed offset if is defined                 // 60\n      log(\"Error syncing to server time: \", err);                                // 61\n      if (++attempts <= maxAttempts)                                             // 62\n        Meteor.setTimeout(TimeSync.resync, 1000);                                // 63\n      else                                                                       // 64\n        log(\"Max number of time sync attempts reached. Giving up.\");             // 65\n      return;                                                                    // 66\n    }                                                                            // 67\n                                                                                 // 68\n    attempts = 0; // It worked                                                   // 69\n                                                                                 // 70\n    var ts = parseInt(response.content);                                         // 71\n    SyncInternals.offset = Math.round(((ts - t0) + (ts - t3)) / 2);              // 72\n    SyncInternals.roundTripTime = t3 - t0; // - (ts - ts) which is 0             // 73\n    SyncInternals.offsetDep.changed();                                           // 74\n  });                                                                            // 75\n};                                                                               // 76\n                                                                                 // 77\n// Reactive variable for server time that updates every second.                  // 78\nTimeSync.serverTime = function(clientTime, interval) {                           // 79\n  check(interval, Match.Optional(Match.Integer));                                // 80\n  // If we don't know the offset, we can't provide the server time.              // 81\n  if ( !TimeSync.isSynced() ) return undefined;                                  // 82\n  // If a client time is provided, we don't need to depend on the tick.          // 83\n  if ( !clientTime ) getTickDependency(interval || defaultInterval).depend();    // 84\n                                                                                 // 85\n  // SyncInternals.offsetDep.depend(); implicit as we call isSynced()            // 86\n  // Convert Date argument to epoch as necessary                                 // 87\n  return (+clientTime || Date.now()) + SyncInternals.offset;                     // 88\n};                                                                               // 89\n                                                                                 // 90\n// Reactive variable for the difference between server and client time.          // 91\nTimeSync.serverOffset = function() {                                             // 92\n  SyncInternals.offsetDep.depend();                                              // 93\n  return SyncInternals.offset;                                                   // 94\n};                                                                               // 95\n                                                                                 // 96\nTimeSync.roundTripTime = function() {                                            // 97\n  SyncInternals.offsetDep.depend();                                              // 98\n  return SyncInternals.roundTripTime;                                            // 99\n};                                                                               // 100\n                                                                                 // 101\nTimeSync.isSynced = function() {                                                 // 102\n  SyncInternals.offsetDep.depend();                                              // 103\n  return SyncInternals.offset !== undefined;                                     // 104\n};                                                                               // 105\n                                                                                 // 106\nvar resyncIntervalId = null;                                                     // 107\n                                                                                 // 108\nTimeSync.resync = function() {                                                   // 109\n  if (resyncIntervalId !== null) Meteor.clearInterval(resyncIntervalId);         // 110\n  updateOffset();                                                                // 111\n  resyncIntervalId = Meteor.setInterval(updateOffset, 600000);                   // 112\n};                                                                               // 113\n                                                                                 // 114\n// Run this as soon as we load, even before Meteor.startup()                     // 115\n// Run again whenever we reconnect after losing connection                       // 116\nvar wasConnected = false;                                                        // 117\n                                                                                 // 118\nDeps.autorun(function() {                                                        // 119\n  var connected = Meteor.status().connected;                                     // 120\n  if ( connected && !wasConnected ) TimeSync.resync();                           // 121\n  wasConnected = connected;                                                      // 122\n});                                                                              // 123\n                                                                                 // 124\n// Resync if unexpected change by more than a few seconds. This needs to be      // 125\n// somewhat lenient, or a CPU-intensive operation can trigger a re-sync even     // 126\n// when the offset is still accurate. In any case, we're not going to be able to // 127\n// catch very small system-initiated NTP adjustments with this, anyway.          // 128\nvar tickCheckTolerance = 5000;                                                   // 129\n                                                                                 // 130\nvar lastClientTime = Date.now();                                                 // 131\n                                                                                 // 132\n// Set up a new interval for any amount of reactivity.                           // 133\nfunction getTickDependency(interval) {                                           // 134\n                                                                                 // 135\n  if ( !SyncInternals.timeTick[interval] ) {                                     // 136\n    var dep  = new Deps.Dependency();                                            // 137\n                                                                                 // 138\n    Meteor.setInterval(function() {                                              // 139\n      dep.changed();                                                             // 140\n    }, interval);                                                                // 141\n                                                                                 // 142\n    SyncInternals.timeTick[interval] = dep;                                      // 143\n  }                                                                              // 144\n                                                                                 // 145\n  return SyncInternals.timeTick[interval];                                       // 146\n}                                                                                // 147\n                                                                                 // 148\n// Set up special interval for the default tick, which also watches for re-sync  // 149\nMeteor.setInterval(function() {                                                  // 150\n  var currentClientTime = Date.now();                                            // 151\n                                                                                 // 152\n  if ( SyncInternals.timeCheck(                                                  // 153\n    lastClientTime, currentClientTime, defaultInterval, tickCheckTolerance) ) {  // 154\n    // No problem here, just keep ticking along                                  // 155\n    SyncInternals.timeTick[defaultInterval].changed();                           // 156\n  }                                                                              // 157\n  else {                                                                         // 158\n    // resync on major client clock changes                                      // 159\n    // based on http://stackoverflow.com/a/3367542/1656818                       // 160\n    log(\"Clock discrepancy detected. Attempting re-sync.\");                      // 161\n    // Refuse to compute server time.                                            // 162\n    SyncInternals.offset = undefined;                                            // 163\n    SyncInternals.offsetDep.changed();                                           // 164\n    TimeSync.resync();                                                           // 165\n  }                                                                              // 166\n                                                                                 // 167\n  lastClientTime = currentClientTime;                                            // 168\n}, defaultInterval);                                                             // 169\n                                                                                 // 170\n                                                                                 // 171\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}}]