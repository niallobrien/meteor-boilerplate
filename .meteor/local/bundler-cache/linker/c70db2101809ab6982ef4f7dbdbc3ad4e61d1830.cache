[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar _ = Package.underscore._;\nvar EJSON = Package.ejson.EJSON;\n\n/* Package-scope variables */\nvar check, Match;\n\n(function(){\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                  //\n// packages/check/match.js                                                                          //\n//                                                                                                  //\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                    //\n// XXX docs                                                                                         // 1\n                                                                                                    // 2\n// Things we explicitly do NOT support:                                                             // 3\n//    - heterogenous arrays                                                                         // 4\n                                                                                                    // 5\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;                                        // 6\n                                                                                                    // 7\n/**                                                                                                 // 8\n * @summary Check that a value matches a [pattern](#matchpatterns).                                 // 9\n * If the value does not match the pattern, throw a `Match.Error`.                                  // 10\n *                                                                                                  // 11\n * Particularly useful to assert that arguments to a function have the right                        // 12\n * types and structure.                                                                             // 13\n * @locus Anywhere                                                                                  // 14\n * @param {Any} value The value to check                                                            // 15\n * @param {MatchPattern} pattern The pattern to match                                               // 16\n * `value` against                                                                                  // 17\n */                                                                                                 // 18\ncheck = function (value, pattern) {                                                                 // 19\n  // Record that check got called, if somebody cared.                                               // 20\n  //                                                                                                // 21\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()                                 // 22\n  // from non-Fiber server contexts; the downside is that if you forget to                          // 23\n  // bindEnvironment on some random callback in your method/publisher,                              // 24\n  // it might not find the argumentChecker and you'll get an error about                            // 25\n  // not checking an argument that it looks like you're checking (instead                           // 26\n  // of just getting a \"Node code must run in a Fiber\" error).                                      // 27\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();                                // 28\n  if (argChecker)                                                                                   // 29\n    argChecker.checking(value);                                                                     // 30\n  try {                                                                                             // 31\n    checkSubtree(value, pattern);                                                                   // 32\n  } catch (err) {                                                                                   // 33\n    if ((err instanceof Match.Error) && err.path)                                                   // 34\n      err.message += \" in field \" + err.path;                                                       // 35\n    throw err;                                                                                      // 36\n  }                                                                                                 // 37\n};                                                                                                  // 38\n                                                                                                    // 39\n/**                                                                                                 // 40\n * @namespace Match                                                                                 // 41\n * @summary The namespace for all Match types and methods.                                          // 42\n */                                                                                                 // 43\nMatch = {                                                                                           // 44\n  Optional: function (pattern) {                                                                    // 45\n    return new Optional(pattern);                                                                   // 46\n  },                                                                                                // 47\n  OneOf: function (/*arguments*/) {                                                                 // 48\n    return new OneOf(_.toArray(arguments));                                                         // 49\n  },                                                                                                // 50\n  Any: ['__any__'],                                                                                 // 51\n  Where: function (condition) {                                                                     // 52\n    return new Where(condition);                                                                    // 53\n  },                                                                                                // 54\n  ObjectIncluding: function (pattern) {                                                             // 55\n    return new ObjectIncluding(pattern);                                                            // 56\n  },                                                                                                // 57\n  ObjectWithValues: function (pattern) {                                                            // 58\n    return new ObjectWithValues(pattern);                                                           // 59\n  },                                                                                                // 60\n  // Matches only signed 32-bit integers                                                            // 61\n  Integer: ['__integer__'],                                                                         // 62\n                                                                                                    // 63\n  // XXX matchers should know how to describe themselves for errors                                 // 64\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {                                       // 65\n    this.message = \"Match error: \" + msg;                                                           // 66\n    // The path of the value that failed to match. Initially empty, this gets                       // 67\n    // populated by catching and rethrowing the exception as it goes back up the                    // 68\n    // stack.                                                                                       // 69\n    // E.g.: \"vals[3].entity.created\"                                                               // 70\n    this.path = \"\";                                                                                 // 71\n    // If this gets sent over DDP, don't give full internal details but at least                    // 72\n    // provide something better than 500 Internal server error.                                     // 73\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");                                    // 74\n  }),                                                                                               // 75\n                                                                                                    // 76\n  // Tests to see if value matches pattern. Unlike check, it merely returns true                    // 77\n  // or false (unless an error other than Match.Error was thrown). It does not                      // 78\n  // interact with _failIfArgumentsAreNotAllChecked.                                                // 79\n  // XXX maybe also implement a Match.match which returns more information about                    // 80\n  //     failures but without using exception handling or doing what check()                        // 81\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion                     // 82\n                                                                                                    // 83\n  /**                                                                                               // 84\n   * @summary Returns true if the value matches the pattern.                                        // 85\n   * @locus Anywhere                                                                                // 86\n   * @param {Any} value The value to check                                                          // 87\n   * @param {MatchPattern} pattern The pattern to match `value` against                             // 88\n   */                                                                                               // 89\n  test: function (value, pattern) {                                                                 // 90\n    try {                                                                                           // 91\n      checkSubtree(value, pattern);                                                                 // 92\n      return true;                                                                                  // 93\n    } catch (e) {                                                                                   // 94\n      if (e instanceof Match.Error)                                                                 // 95\n        return false;                                                                               // 96\n      // Rethrow other errors.                                                                      // 97\n      throw e;                                                                                      // 98\n    }                                                                                               // 99\n  },                                                                                                // 100\n                                                                                                    // 101\n  // Runs `f.apply(context, args)`. If check() is not called on every element of                    // 102\n  // `args` (either directly or in the first level of an array), throws an error                    // 103\n  // (using `description` in the message).                                                          // 104\n  //                                                                                                // 105\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {                      // 106\n    var argChecker = new ArgumentChecker(args, description);                                        // 107\n    var result = currentArgumentChecker.withValue(argChecker, function () {                         // 108\n      return f.apply(context, args);                                                                // 109\n    });                                                                                             // 110\n    // If f didn't itself throw, make sure it checked all of its arguments.                         // 111\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();                                            // 112\n    return result;                                                                                  // 113\n  }                                                                                                 // 114\n};                                                                                                  // 115\n                                                                                                    // 116\nvar Optional = function (pattern) {                                                                 // 117\n  this.pattern = pattern;                                                                           // 118\n};                                                                                                  // 119\n                                                                                                    // 120\nvar OneOf = function (choices) {                                                                    // 121\n  if (_.isEmpty(choices))                                                                           // 122\n    throw new Error(\"Must provide at least one choice to Match.OneOf\");                             // 123\n  this.choices = choices;                                                                           // 124\n};                                                                                                  // 125\n                                                                                                    // 126\nvar Where = function (condition) {                                                                  // 127\n  this.condition = condition;                                                                       // 128\n};                                                                                                  // 129\n                                                                                                    // 130\nvar ObjectIncluding = function (pattern) {                                                          // 131\n  this.pattern = pattern;                                                                           // 132\n};                                                                                                  // 133\n                                                                                                    // 134\nvar ObjectWithValues = function (pattern) {                                                         // 135\n  this.pattern = pattern;                                                                           // 136\n};                                                                                                  // 137\n                                                                                                    // 138\nvar typeofChecks = [                                                                                // 139\n  [String, \"string\"],                                                                               // 140\n  [Number, \"number\"],                                                                               // 141\n  [Boolean, \"boolean\"],                                                                             // 142\n  // While we don't allow undefined in EJSON, this is good for optional                             // 143\n  // arguments with OneOf.                                                                          // 144\n  [undefined, \"undefined\"]                                                                          // 145\n];                                                                                                  // 146\n                                                                                                    // 147\nvar checkSubtree = function (value, pattern) {                                                      // 148\n  // Match anything!                                                                                // 149\n  if (pattern === Match.Any)                                                                        // 150\n    return;                                                                                         // 151\n                                                                                                    // 152\n  // Basic atomic types.                                                                            // 153\n  // Do not match boxed objects (e.g. String, Boolean)                                              // 154\n  for (var i = 0; i < typeofChecks.length; ++i) {                                                   // 155\n    if (pattern === typeofChecks[i][0]) {                                                           // 156\n      if (typeof value === typeofChecks[i][1])                                                      // 157\n        return;                                                                                     // 158\n      throw new Match.Error(\"Expected \" + typeofChecks[i][1] + \", got \" +                           // 159\n                            typeof value);                                                          // 160\n    }                                                                                               // 161\n  }                                                                                                 // 162\n  if (pattern === null) {                                                                           // 163\n    if (value === null)                                                                             // 164\n      return;                                                                                       // 165\n    throw new Match.Error(\"Expected null, got \" + EJSON.stringify(value));                          // 166\n  }                                                                                                 // 167\n                                                                                                    // 168\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.                    // 169\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {\n    if (value === pattern)                                                                          // 171\n      return;                                                                                       // 172\n    throw new Match.Error(\"Expected \" + pattern + \", got \" +                                        // 173\n                          EJSON.stringify(value));                                                  // 174\n  }                                                                                                 // 175\n                                                                                                    // 176\n  // Match.Integer is special type encoded with array                                               // 177\n  if (pattern === Match.Integer) {                                                                  // 178\n    // There is no consistent and reliable way to check if variable is a 64-bit                     // 179\n    // integer. One of the popular solutions is to get reminder of division by 1                    // 180\n    // but this method fails on really large floats with big precision.                             // 181\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8                                                  // 182\n    // Bitwise operators work consistantly but always cast variable to 32-bit                       // 183\n    // signed integer according to JavaScript specs.                                                // 184\n    if (typeof value === \"number\" && (value | 0) === value)                                         // 185\n      return                                                                                        // 186\n    throw new Match.Error(\"Expected Integer, got \"                                                  // 187\n                + (value instanceof Object ? EJSON.stringify(value) : value));                      // 188\n  }                                                                                                 // 189\n                                                                                                    // 190\n  // \"Object\" is shorthand for Match.ObjectIncluding({});                                           // 191\n  if (pattern === Object)                                                                           // 192\n    pattern = Match.ObjectIncluding({});                                                            // 193\n                                                                                                    // 194\n  // Array (checked AFTER Any, which is implemented as an Array).                                   // 195\n  if (pattern instanceof Array) {                                                                   // 196\n    if (pattern.length !== 1)                                                                       // 197\n      throw Error(\"Bad pattern: arrays must have one type element\" +                                // 198\n                  EJSON.stringify(pattern));                                                        // 199\n    if (!_.isArray(value) && !_.isArguments(value)) {                                               // 200\n      throw new Match.Error(\"Expected array, got \" + EJSON.stringify(value));                       // 201\n    }                                                                                               // 202\n                                                                                                    // 203\n    _.each(value, function (valueElement, index) {                                                  // 204\n      try {                                                                                         // 205\n        checkSubtree(valueElement, pattern[0]);                                                     // 206\n      } catch (err) {                                                                               // 207\n        if (err instanceof Match.Error) {                                                           // 208\n          err.path = _prependPath(index, err.path);                                                 // 209\n        }                                                                                           // 210\n        throw err;                                                                                  // 211\n      }                                                                                             // 212\n    });                                                                                             // 213\n    return;                                                                                         // 214\n  }                                                                                                 // 215\n                                                                                                    // 216\n  // Arbitrary validation checks. The condition can return false or throw a                         // 217\n  // Match.Error (ie, it can internally use check()) to fail.                                       // 218\n  if (pattern instanceof Where) {                                                                   // 219\n    if (pattern.condition(value))                                                                   // 220\n      return;                                                                                       // 221\n    // XXX this error is terrible                                                                   // 222\n    throw new Match.Error(\"Failed Match.Where validation\");                                         // 223\n  }                                                                                                 // 224\n                                                                                                    // 225\n                                                                                                    // 226\n  if (pattern instanceof Optional)                                                                  // 227\n    pattern = Match.OneOf(undefined, pattern.pattern);                                              // 228\n                                                                                                    // 229\n  if (pattern instanceof OneOf) {                                                                   // 230\n    for (var i = 0; i < pattern.choices.length; ++i) {                                              // 231\n      try {                                                                                         // 232\n        checkSubtree(value, pattern.choices[i]);                                                    // 233\n        // No error? Yay, return.                                                                   // 234\n        return;                                                                                     // 235\n      } catch (err) {                                                                               // 236\n        // Other errors should be thrown. Match errors just mean try another                        // 237\n        // choice.                                                                                  // 238\n        if (!(err instanceof Match.Error))                                                          // 239\n          throw err;                                                                                // 240\n      }                                                                                             // 241\n    }                                                                                               // 242\n    // XXX this error is terrible                                                                   // 243\n    throw new Match.Error(\"Failed Match.OneOf or Match.Optional validation\");                       // 244\n  }                                                                                                 // 245\n                                                                                                    // 246\n  // A function that isn't something we special-case is assumed to be a                             // 247\n  // constructor.                                                                                   // 248\n  if (pattern instanceof Function) {                                                                // 249\n    if (value instanceof pattern)                                                                   // 250\n      return;                                                                                       // 251\n    throw new Match.Error(\"Expected \" + (pattern.name ||                                            // 252\n                                         \"particular constructor\"));                                // 253\n  }                                                                                                 // 254\n                                                                                                    // 255\n  var unknownKeysAllowed = false;                                                                   // 256\n  var unknownKeyPattern;                                                                            // 257\n  if (pattern instanceof ObjectIncluding) {                                                         // 258\n    unknownKeysAllowed = true;                                                                      // 259\n    pattern = pattern.pattern;                                                                      // 260\n  }                                                                                                 // 261\n  if (pattern instanceof ObjectWithValues) {                                                        // 262\n    unknownKeysAllowed = true;                                                                      // 263\n    unknownKeyPattern = [pattern.pattern];                                                          // 264\n    pattern = {};  // no required keys                                                              // 265\n  }                                                                                                 // 266\n                                                                                                    // 267\n  if (typeof pattern !== \"object\")                                                                  // 268\n    throw Error(\"Bad pattern: unknown pattern type\");                                               // 269\n                                                                                                    // 270\n  // An object, with required and optional keys. Note that this does NOT do                         // 271\n  // structural matches against objects of special types that happen to match                       // 272\n  // the pattern: this really needs to be a plain old {Object}!                                     // 273\n  if (typeof value !== 'object')                                                                    // 274\n    throw new Match.Error(\"Expected object, got \" + typeof value);                                  // 275\n  if (value === null)                                                                               // 276\n    throw new Match.Error(\"Expected object, got null\");                                             // 277\n  if (value.constructor !== Object)                                                                 // 278\n    throw new Match.Error(\"Expected plain object\");                                                 // 279\n                                                                                                    // 280\n  var requiredPatterns = {};                                                                        // 281\n  var optionalPatterns = {};                                                                        // 282\n  _.each(pattern, function (subPattern, key) {                                                      // 283\n    if (subPattern instanceof Optional)                                                             // 284\n      optionalPatterns[key] = subPattern.pattern;                                                   // 285\n    else                                                                                            // 286\n      requiredPatterns[key] = subPattern;                                                           // 287\n  });                                                                                               // 288\n                                                                                                    // 289\n  _.each(value, function (subValue, key) {                                                          // 290\n    try {                                                                                           // 291\n      if (_.has(requiredPatterns, key)) {                                                           // 292\n        checkSubtree(subValue, requiredPatterns[key]);                                              // 293\n        delete requiredPatterns[key];                                                               // 294\n      } else if (_.has(optionalPatterns, key)) {                                                    // 295\n        checkSubtree(subValue, optionalPatterns[key]);                                              // 296\n      } else {                                                                                      // 297\n        if (!unknownKeysAllowed)                                                                    // 298\n          throw new Match.Error(\"Unknown key\");                                                     // 299\n        if (unknownKeyPattern) {                                                                    // 300\n          checkSubtree(subValue, unknownKeyPattern[0]);                                             // 301\n        }                                                                                           // 302\n      }                                                                                             // 303\n    } catch (err) {                                                                                 // 304\n      if (err instanceof Match.Error)                                                               // 305\n        err.path = _prependPath(key, err.path);                                                     // 306\n      throw err;                                                                                    // 307\n    }                                                                                               // 308\n  });                                                                                               // 309\n                                                                                                    // 310\n  _.each(requiredPatterns, function (subPattern, key) {                                             // 311\n    throw new Match.Error(\"Missing key '\" + key + \"'\");                                             // 312\n  });                                                                                               // 313\n};                                                                                                  // 314\n                                                                                                    // 315\nvar ArgumentChecker = function (args, description) {                                                // 316\n  var self = this;                                                                                  // 317\n  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks                          // 318\n  // against its contents.)                                                                         // 319\n  self.args = _.clone(args);                                                                        // 320\n  // Since the common case will be to check arguments in order, and we splice                       // 321\n  // out arguments when we check them, make it so we splice out from the end                        // 322\n  // rather than the beginning.                                                                     // 323\n  self.args.reverse();                                                                              // 324\n  self.description = description;                                                                   // 325\n};                                                                                                  // 326\n                                                                                                    // 327\n_.extend(ArgumentChecker.prototype, {                                                               // 328\n  checking: function (value) {                                                                      // 329\n    var self = this;                                                                                // 330\n    if (self._checkingOneValue(value))                                                              // 331\n      return;                                                                                       // 332\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])                      // 333\n    // or check([foo, bar], [String]) to count... but only if value wasn't                          // 334\n    // itself an argument.                                                                          // 335\n    if (_.isArray(value) || _.isArguments(value)) {                                                 // 336\n      _.each(value, _.bind(self._checkingOneValue, self));                                          // 337\n    }                                                                                               // 338\n  },                                                                                                // 339\n  _checkingOneValue: function (value) {                                                             // 340\n    var self = this;                                                                                // 341\n    for (var i = 0; i < self.args.length; ++i) {                                                    // 342\n      // Is this value one of the arguments? (This can have a false positive if                     // 343\n      // the argument is an interned primitive, but it's still a good enough                        // 344\n      // check.)                                                                                    // 345\n      // (NaN is not === to itself, so we have to check specially.)                                 // 346\n      if (value === self.args[i] || (_.isNaN(value) && _.isNaN(self.args[i]))) {                    // 347\n        self.args.splice(i, 1);                                                                     // 348\n        return true;                                                                                // 349\n      }                                                                                             // 350\n    }                                                                                               // 351\n    return false;                                                                                   // 352\n  },                                                                                                // 353\n  throwUnlessAllArgumentsHaveBeenChecked: function () {                                             // 354\n    var self = this;                                                                                // 355\n    if (!_.isEmpty(self.args))                                                                      // 356\n      throw new Error(\"Did not check() all arguments during \" +                                     // 357\n                      self.description);                                                            // 358\n  }                                                                                                 // 359\n});                                                                                                 // 360\n                                                                                                    // 361\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",                     // 362\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",                          // 363\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",                           // 364\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",                             // 365\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",                      // 366\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",                      // 367\n  \"instanceof\"];                                                                                    // 368\n                                                                                                    // 369\n// Assumes the base of path is already escaped properly                                             // 370\n// returns key + base                                                                               // 371\nvar _prependPath = function (key, base) {                                                           // 372\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))                                           // 373\n    key = \"[\" + key + \"]\";                                                                          // 374\n  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))                     // 375\n    key = JSON.stringify([key]);                                                                    // 376\n                                                                                                    // 377\n  if (base && base[0] !== \"[\")                                                                      // 378\n    return key + '.' + base;                                                                        // 379\n  return key + base;                                                                                // 380\n};                                                                                                  // 381\n                                                                                                    // 382\n                                                                                                    // 383\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.check = {\n  check: check,\n  Match: Match\n};\n\n})();\n","servePath":"/packages/check.js","sourceMap":{"version":3,"sources":["/packages/check/match.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0G","file":"/packages/check.js","sourcesContent":["// XXX docs\n\n// Things we explicitly do NOT support:\n//    - heterogenous arrays\n\nvar currentArgumentChecker = new Meteor.EnvironmentVariable;\n\n/**\n * @summary Check that a value matches a [pattern](#matchpatterns).\n * If the value does not match the pattern, throw a `Match.Error`.\n *\n * Particularly useful to assert that arguments to a function have the right\n * types and structure.\n * @locus Anywhere\n * @param {Any} value The value to check\n * @param {MatchPattern} pattern The pattern to match\n * `value` against\n */\ncheck = function (value, pattern) {\n  // Record that check got called, if somebody cared.\n  //\n  // We use getOrNullIfOutsideFiber so that it's OK to call check()\n  // from non-Fiber server contexts; the downside is that if you forget to\n  // bindEnvironment on some random callback in your method/publisher,\n  // it might not find the argumentChecker and you'll get an error about\n  // not checking an argument that it looks like you're checking (instead\n  // of just getting a \"Node code must run in a Fiber\" error).\n  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();\n  if (argChecker)\n    argChecker.checking(value);\n  try {\n    checkSubtree(value, pattern);\n  } catch (err) {\n    if ((err instanceof Match.Error) && err.path)\n      err.message += \" in field \" + err.path;\n    throw err;\n  }\n};\n\n/**\n * @namespace Match\n * @summary The namespace for all Match types and methods.\n */\nMatch = {\n  Optional: function (pattern) {\n    return new Optional(pattern);\n  },\n  OneOf: function (/*arguments*/) {\n    return new OneOf(_.toArray(arguments));\n  },\n  Any: ['__any__'],\n  Where: function (condition) {\n    return new Where(condition);\n  },\n  ObjectIncluding: function (pattern) {\n    return new ObjectIncluding(pattern);\n  },\n  ObjectWithValues: function (pattern) {\n    return new ObjectWithValues(pattern);\n  },\n  // Matches only signed 32-bit integers\n  Integer: ['__integer__'],\n\n  // XXX matchers should know how to describe themselves for errors\n  Error: Meteor.makeErrorType(\"Match.Error\", function (msg) {\n    this.message = \"Match error: \" + msg;\n    // The path of the value that failed to match. Initially empty, this gets\n    // populated by catching and rethrowing the exception as it goes back up the\n    // stack.\n    // E.g.: \"vals[3].entity.created\"\n    this.path = \"\";\n    // If this gets sent over DDP, don't give full internal details but at least\n    // provide something better than 500 Internal server error.\n    this.sanitizedError = new Meteor.Error(400, \"Match failed\");\n  }),\n\n  // Tests to see if value matches pattern. Unlike check, it merely returns true\n  // or false (unless an error other than Match.Error was thrown). It does not\n  // interact with _failIfArgumentsAreNotAllChecked.\n  // XXX maybe also implement a Match.match which returns more information about\n  //     failures but without using exception handling or doing what check()\n  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion\n\n  /**\n   * @summary Returns true if the value matches the pattern.\n   * @locus Anywhere\n   * @param {Any} value The value to check\n   * @param {MatchPattern} pattern The pattern to match `value` against\n   */\n  test: function (value, pattern) {\n    try {\n      checkSubtree(value, pattern);\n      return true;\n    } catch (e) {\n      if (e instanceof Match.Error)\n        return false;\n      // Rethrow other errors.\n      throw e;\n    }\n  },\n\n  // Runs `f.apply(context, args)`. If check() is not called on every element of\n  // `args` (either directly or in the first level of an array), throws an error\n  // (using `description` in the message).\n  //\n  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {\n    var argChecker = new ArgumentChecker(args, description);\n    var result = currentArgumentChecker.withValue(argChecker, function () {\n      return f.apply(context, args);\n    });\n    // If f didn't itself throw, make sure it checked all of its arguments.\n    argChecker.throwUnlessAllArgumentsHaveBeenChecked();\n    return result;\n  }\n};\n\nvar Optional = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar OneOf = function (choices) {\n  if (_.isEmpty(choices))\n    throw new Error(\"Must provide at least one choice to Match.OneOf\");\n  this.choices = choices;\n};\n\nvar Where = function (condition) {\n  this.condition = condition;\n};\n\nvar ObjectIncluding = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar ObjectWithValues = function (pattern) {\n  this.pattern = pattern;\n};\n\nvar typeofChecks = [\n  [String, \"string\"],\n  [Number, \"number\"],\n  [Boolean, \"boolean\"],\n  // While we don't allow undefined in EJSON, this is good for optional\n  // arguments with OneOf.\n  [undefined, \"undefined\"]\n];\n\nvar checkSubtree = function (value, pattern) {\n  // Match anything!\n  if (pattern === Match.Any)\n    return;\n\n  // Basic atomic types.\n  // Do not match boxed objects (e.g. String, Boolean)\n  for (var i = 0; i < typeofChecks.length; ++i) {\n    if (pattern === typeofChecks[i][0]) {\n      if (typeof value === typeofChecks[i][1])\n        return;\n      throw new Match.Error(\"Expected \" + typeofChecks[i][1] + \", got \" +\n                            typeof value);\n    }\n  }\n  if (pattern === null) {\n    if (value === null)\n      return;\n    throw new Match.Error(\"Expected null, got \" + EJSON.stringify(value));\n  }\n\n  // Strings, numbers, and booleans match literally. Goes well with Match.OneOf.\n  if (typeof pattern === \"string\" || typeof pattern === \"number\" || typeof pattern === \"boolean\") {\n    if (value === pattern)\n      return;\n    throw new Match.Error(\"Expected \" + pattern + \", got \" +\n                          EJSON.stringify(value));\n  }\n\n  // Match.Integer is special type encoded with array\n  if (pattern === Match.Integer) {\n    // There is no consistent and reliable way to check if variable is a 64-bit\n    // integer. One of the popular solutions is to get reminder of division by 1\n    // but this method fails on really large floats with big precision.\n    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8\n    // Bitwise operators work consistantly but always cast variable to 32-bit\n    // signed integer according to JavaScript specs.\n    if (typeof value === \"number\" && (value | 0) === value)\n      return\n    throw new Match.Error(\"Expected Integer, got \"\n                + (value instanceof Object ? EJSON.stringify(value) : value));\n  }\n\n  // \"Object\" is shorthand for Match.ObjectIncluding({});\n  if (pattern === Object)\n    pattern = Match.ObjectIncluding({});\n\n  // Array (checked AFTER Any, which is implemented as an Array).\n  if (pattern instanceof Array) {\n    if (pattern.length !== 1)\n      throw Error(\"Bad pattern: arrays must have one type element\" +\n                  EJSON.stringify(pattern));\n    if (!_.isArray(value) && !_.isArguments(value)) {\n      throw new Match.Error(\"Expected array, got \" + EJSON.stringify(value));\n    }\n\n    _.each(value, function (valueElement, index) {\n      try {\n        checkSubtree(valueElement, pattern[0]);\n      } catch (err) {\n        if (err instanceof Match.Error) {\n          err.path = _prependPath(index, err.path);\n        }\n        throw err;\n      }\n    });\n    return;\n  }\n\n  // Arbitrary validation checks. The condition can return false or throw a\n  // Match.Error (ie, it can internally use check()) to fail.\n  if (pattern instanceof Where) {\n    if (pattern.condition(value))\n      return;\n    // XXX this error is terrible\n    throw new Match.Error(\"Failed Match.Where validation\");\n  }\n\n\n  if (pattern instanceof Optional)\n    pattern = Match.OneOf(undefined, pattern.pattern);\n\n  if (pattern instanceof OneOf) {\n    for (var i = 0; i < pattern.choices.length; ++i) {\n      try {\n        checkSubtree(value, pattern.choices[i]);\n        // No error? Yay, return.\n        return;\n      } catch (err) {\n        // Other errors should be thrown. Match errors just mean try another\n        // choice.\n        if (!(err instanceof Match.Error))\n          throw err;\n      }\n    }\n    // XXX this error is terrible\n    throw new Match.Error(\"Failed Match.OneOf or Match.Optional validation\");\n  }\n\n  // A function that isn't something we special-case is assumed to be a\n  // constructor.\n  if (pattern instanceof Function) {\n    if (value instanceof pattern)\n      return;\n    throw new Match.Error(\"Expected \" + (pattern.name ||\n                                         \"particular constructor\"));\n  }\n\n  var unknownKeysAllowed = false;\n  var unknownKeyPattern;\n  if (pattern instanceof ObjectIncluding) {\n    unknownKeysAllowed = true;\n    pattern = pattern.pattern;\n  }\n  if (pattern instanceof ObjectWithValues) {\n    unknownKeysAllowed = true;\n    unknownKeyPattern = [pattern.pattern];\n    pattern = {};  // no required keys\n  }\n\n  if (typeof pattern !== \"object\")\n    throw Error(\"Bad pattern: unknown pattern type\");\n\n  // An object, with required and optional keys. Note that this does NOT do\n  // structural matches against objects of special types that happen to match\n  // the pattern: this really needs to be a plain old {Object}!\n  if (typeof value !== 'object')\n    throw new Match.Error(\"Expected object, got \" + typeof value);\n  if (value === null)\n    throw new Match.Error(\"Expected object, got null\");\n  if (value.constructor !== Object)\n    throw new Match.Error(\"Expected plain object\");\n\n  var requiredPatterns = {};\n  var optionalPatterns = {};\n  _.each(pattern, function (subPattern, key) {\n    if (subPattern instanceof Optional)\n      optionalPatterns[key] = subPattern.pattern;\n    else\n      requiredPatterns[key] = subPattern;\n  });\n\n  _.each(value, function (subValue, key) {\n    try {\n      if (_.has(requiredPatterns, key)) {\n        checkSubtree(subValue, requiredPatterns[key]);\n        delete requiredPatterns[key];\n      } else if (_.has(optionalPatterns, key)) {\n        checkSubtree(subValue, optionalPatterns[key]);\n      } else {\n        if (!unknownKeysAllowed)\n          throw new Match.Error(\"Unknown key\");\n        if (unknownKeyPattern) {\n          checkSubtree(subValue, unknownKeyPattern[0]);\n        }\n      }\n    } catch (err) {\n      if (err instanceof Match.Error)\n        err.path = _prependPath(key, err.path);\n      throw err;\n    }\n  });\n\n  _.each(requiredPatterns, function (subPattern, key) {\n    throw new Match.Error(\"Missing key '\" + key + \"'\");\n  });\n};\n\nvar ArgumentChecker = function (args, description) {\n  var self = this;\n  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks\n  // against its contents.)\n  self.args = _.clone(args);\n  // Since the common case will be to check arguments in order, and we splice\n  // out arguments when we check them, make it so we splice out from the end\n  // rather than the beginning.\n  self.args.reverse();\n  self.description = description;\n};\n\n_.extend(ArgumentChecker.prototype, {\n  checking: function (value) {\n    var self = this;\n    if (self._checkingOneValue(value))\n      return;\n    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])\n    // or check([foo, bar], [String]) to count... but only if value wasn't\n    // itself an argument.\n    if (_.isArray(value) || _.isArguments(value)) {\n      _.each(value, _.bind(self._checkingOneValue, self));\n    }\n  },\n  _checkingOneValue: function (value) {\n    var self = this;\n    for (var i = 0; i < self.args.length; ++i) {\n      // Is this value one of the arguments? (This can have a false positive if\n      // the argument is an interned primitive, but it's still a good enough\n      // check.)\n      // (NaN is not === to itself, so we have to check specially.)\n      if (value === self.args[i] || (_.isNaN(value) && _.isNaN(self.args[i]))) {\n        self.args.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  },\n  throwUnlessAllArgumentsHaveBeenChecked: function () {\n    var self = this;\n    if (!_.isEmpty(self.args))\n      throw new Error(\"Did not check() all arguments during \" +\n                      self.description);\n  }\n});\n\nvar _jsKeywords = [\"do\", \"if\", \"in\", \"for\", \"let\", \"new\", \"try\", \"var\", \"case\",\n  \"else\", \"enum\", \"eval\", \"false\", \"null\", \"this\", \"true\", \"void\", \"with\",\n  \"break\", \"catch\", \"class\", \"const\", \"super\", \"throw\", \"while\", \"yield\",\n  \"delete\", \"export\", \"import\", \"public\", \"return\", \"static\", \"switch\",\n  \"typeof\", \"default\", \"extends\", \"finally\", \"package\", \"private\", \"continue\",\n  \"debugger\", \"function\", \"arguments\", \"interface\", \"protected\", \"implements\",\n  \"instanceof\"];\n\n// Assumes the base of path is already escaped properly\n// returns key + base\nvar _prependPath = function (key, base) {\n  if ((typeof key) === \"number\" || key.match(/^[0-9]+$/))\n    key = \"[\" + key + \"]\";\n  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))\n    key = JSON.stringify([key]);\n\n  if (base && base[0] !== \"[\")\n    return key + '.' + base;\n  return key + base;\n};\n\n"]}}]