[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\n\n/* Package-scope variables */\nvar Promise;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/promise/.npm/package/node_modules/meteor-promise/promise.bundle.js                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/******/ (function(modules) { // webpackBootstrap                                                                    // 1\n/******/ \t// The module cache                                                                                        // 2\n/******/ \tvar installedModules = {};                                                                                 // 3\n                                                                                                                     // 4\n/******/ \t// The require function                                                                                    // 5\n/******/ \tfunction __webpack_require__(moduleId) {                                                                   // 6\n                                                                                                                     // 7\n/******/ \t\t// Check if module is in cache                                                                            // 8\n/******/ \t\tif(installedModules[moduleId])                                                                            // 9\n/******/ \t\t\treturn installedModules[moduleId].exports;                                                               // 10\n                                                                                                                     // 11\n/******/ \t\t// Create a new module (and put it into the cache)                                                        // 12\n/******/ \t\tvar module = installedModules[moduleId] = {                                                               // 13\n/******/ \t\t\texports: {},                                                                                             // 14\n/******/ \t\t\tid: moduleId,                                                                                            // 15\n/******/ \t\t\tloaded: false                                                                                            // 16\n/******/ \t\t};                                                                                                        // 17\n                                                                                                                     // 18\n/******/ \t\t// Execute the module function                                                                            // 19\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);                      // 20\n                                                                                                                     // 21\n/******/ \t\t// Flag the module as loaded                                                                              // 22\n/******/ \t\tmodule.loaded = true;                                                                                     // 23\n                                                                                                                     // 24\n/******/ \t\t// Return the exports of the module                                                                       // 25\n/******/ \t\treturn module.exports;                                                                                    // 26\n/******/ \t}                                                                                                          // 27\n                                                                                                                     // 28\n                                                                                                                     // 29\n/******/ \t// expose the modules object (__webpack_modules__)                                                         // 30\n/******/ \t__webpack_require__.m = modules;                                                                           // 31\n                                                                                                                     // 32\n/******/ \t// expose the module cache                                                                                 // 33\n/******/ \t__webpack_require__.c = installedModules;                                                                  // 34\n                                                                                                                     // 35\n/******/ \t// __webpack_public_path__                                                                                 // 36\n/******/ \t__webpack_require__.p = \"\";                                                                                // 37\n                                                                                                                     // 38\n/******/ \t// Load entry module and return exports                                                                    // 39\n/******/ \treturn __webpack_require__(0);                                                                             // 40\n/******/ })                                                                                                          // 41\n/************************************************************************/                                           // 42\n/******/ ([                                                                                                          // 43\n/* 0 */                                                                                                              // 44\n/***/ function(module, exports, __webpack_require__) {                                                               // 45\n                                                                                                                     // 46\n\t// See https://github.com/then/promise#usage for an explanation of why we                                           // 47\n\t// require promise/domains here.                                                                                    // 48\n\tvar MeteorPromise = __webpack_require__(1);                                                                         // 49\n                                                                                                                     // 50\n\tvar es6PromiseThen = MeteorPromise.prototype.then;                                                                  // 51\n\tMeteorPromise.prototype.then = function (onResolved, onRejected) {                                                  // 52\n\t  if (typeof Meteor === \"object\" &&                                                                                 // 53\n\t      typeof Meteor.bindEnvironment === \"function\") {                                                               // 54\n\t    return es6PromiseThen.call(                                                                                     // 55\n\t      this,                                                                                                         // 56\n\t      onResolved && Meteor.bindEnvironment(onResolved, raise),                                                      // 57\n\t      onRejected && Meteor.bindEnvironment(onRejected, raise)                                                       // 58\n\t    );                                                                                                              // 59\n\t  }                                                                                                                 // 60\n\t  return es6PromiseThen.call(this, onResolved, onRejected);                                                         // 61\n\t};                                                                                                                  // 62\n                                                                                                                     // 63\n\tfunction raise(exception) {                                                                                         // 64\n\t  throw exception;                                                                                                  // 65\n\t}                                                                                                                   // 66\n                                                                                                                     // 67\n\tPromise = MeteorPromise;                                                                                            // 68\n                                                                                                                     // 69\n                                                                                                                     // 70\n/***/ },                                                                                                             // 71\n/* 1 */                                                                                                              // 72\n/***/ function(module, exports, __webpack_require__) {                                                               // 73\n                                                                                                                     // 74\n\t'use strict';                                                                                                       // 75\n                                                                                                                     // 76\n\tmodule.exports = __webpack_require__(2);                                                                            // 77\n\t__webpack_require__(3);                                                                                             // 78\n\t__webpack_require__(4);                                                                                             // 79\n\t__webpack_require__(5);                                                                                             // 80\n\t__webpack_require__(6);                                                                                             // 81\n                                                                                                                     // 82\n                                                                                                                     // 83\n/***/ },                                                                                                             // 84\n/* 2 */                                                                                                              // 85\n/***/ function(module, exports, __webpack_require__) {                                                               // 86\n                                                                                                                     // 87\n\t'use strict';                                                                                                       // 88\n                                                                                                                     // 89\n\tvar asap = __webpack_require__(7);                                                                                  // 90\n                                                                                                                     // 91\n\tfunction noop() {}                                                                                                  // 92\n                                                                                                                     // 93\n\t// States:                                                                                                          // 94\n\t//                                                                                                                  // 95\n\t// 0 - pending                                                                                                      // 96\n\t// 1 - fulfilled with _value                                                                                        // 97\n\t// 2 - rejected with _value                                                                                         // 98\n\t// 3 - adopted the state of another promise, _value                                                                 // 99\n\t//                                                                                                                  // 100\n\t// once the state is no longer pending (0) it is immutable                                                          // 101\n                                                                                                                     // 102\n\t// All `_` prefixed properties will be reduced to `_{random number}`                                                // 103\n\t// at build time to obfuscate them and discourage their use.                                                        // 104\n\t// We don't use symbols or Object.defineProperty to fully hide them                                                 // 105\n\t// because the performance isn't good enough.                                                                       // 106\n                                                                                                                     // 107\n                                                                                                                     // 108\n\t// to avoid using try/catch inside critical functions, we                                                           // 109\n\t// extract them to here.                                                                                            // 110\n\tvar LAST_ERROR = null;                                                                                              // 111\n\tvar IS_ERROR = {};                                                                                                  // 112\n\tfunction getThen(obj) {                                                                                             // 113\n\t  try {                                                                                                             // 114\n\t    return obj.then;                                                                                                // 115\n\t  } catch (ex) {                                                                                                    // 116\n\t    LAST_ERROR = ex;                                                                                                // 117\n\t    return IS_ERROR;                                                                                                // 118\n\t  }                                                                                                                 // 119\n\t}                                                                                                                   // 120\n                                                                                                                     // 121\n\tfunction tryCallOne(fn, a) {                                                                                        // 122\n\t  try {                                                                                                             // 123\n\t    return fn(a);                                                                                                   // 124\n\t  } catch (ex) {                                                                                                    // 125\n\t    LAST_ERROR = ex;                                                                                                // 126\n\t    return IS_ERROR;                                                                                                // 127\n\t  }                                                                                                                 // 128\n\t}                                                                                                                   // 129\n\tfunction tryCallTwo(fn, a, b) {                                                                                     // 130\n\t  try {                                                                                                             // 131\n\t    fn(a, b);                                                                                                       // 132\n\t  } catch (ex) {                                                                                                    // 133\n\t    LAST_ERROR = ex;                                                                                                // 134\n\t    return IS_ERROR;                                                                                                // 135\n\t  }                                                                                                                 // 136\n\t}                                                                                                                   // 137\n                                                                                                                     // 138\n\tmodule.exports = Promise;                                                                                           // 139\n                                                                                                                     // 140\n\tfunction Promise(fn) {                                                                                              // 141\n\t  if (typeof this !== 'object') {                                                                                   // 142\n\t    throw new TypeError('Promises must be constructed via new');                                                    // 143\n\t  }                                                                                                                 // 144\n\t  if (typeof fn !== 'function') {                                                                                   // 145\n\t    throw new TypeError('not a function');                                                                          // 146\n\t  }                                                                                                                 // 147\n\t  this._37 = 0;                                                                                                     // 148\n\t  this._12 = null;                                                                                                  // 149\n\t  this._59 = [];                                                                                                    // 150\n\t  if (fn === noop) return;                                                                                          // 151\n\t  doResolve(fn, this);                                                                                              // 152\n\t}                                                                                                                   // 153\n\tPromise._99 = noop;                                                                                                 // 154\n                                                                                                                     // 155\n\tPromise.prototype.then = function(onFulfilled, onRejected) {                                                        // 156\n\t  if (this.constructor !== Promise) {                                                                               // 157\n\t    return safeThen(this, onFulfilled, onRejected);                                                                 // 158\n\t  }                                                                                                                 // 159\n\t  var res = new Promise(noop);                                                                                      // 160\n\t  handle(this, new Handler(onFulfilled, onRejected, res));                                                          // 161\n\t  return res;                                                                                                       // 162\n\t};                                                                                                                  // 163\n                                                                                                                     // 164\n\tfunction safeThen(self, onFulfilled, onRejected) {                                                                  // 165\n\t  return new self.constructor(function (resolve, reject) {                                                          // 166\n\t    var res = new Promise(noop);                                                                                    // 167\n\t    res.then(resolve, reject);                                                                                      // 168\n\t    handle(self, new Handler(onFulfilled, onRejected, res));                                                        // 169\n\t  });                                                                                                               // 170\n\t};                                                                                                                  // 171\n\tfunction handle(self, deferred) {                                                                                   // 172\n\t  while (self._37 === 3) {                                                                                          // 173\n\t    self = self._12;                                                                                                // 174\n\t  }                                                                                                                 // 175\n\t  if (self._37 === 0) {                                                                                             // 176\n\t    self._59.push(deferred);                                                                                        // 177\n\t    return;                                                                                                         // 178\n\t  }                                                                                                                 // 179\n\t  asap(function() {                                                                                                 // 180\n\t    var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;                                           // 181\n\t    if (cb === null) {                                                                                              // 182\n\t      if (self._37 === 1) {                                                                                         // 183\n\t        resolve(deferred.promise, self._12);                                                                        // 184\n\t      } else {                                                                                                      // 185\n\t        reject(deferred.promise, self._12);                                                                         // 186\n\t      }                                                                                                             // 187\n\t      return;                                                                                                       // 188\n\t    }                                                                                                               // 189\n\t    var ret = tryCallOne(cb, self._12);                                                                             // 190\n\t    if (ret === IS_ERROR) {                                                                                         // 191\n\t      reject(deferred.promise, LAST_ERROR);                                                                         // 192\n\t    } else {                                                                                                        // 193\n\t      resolve(deferred.promise, ret);                                                                               // 194\n\t    }                                                                                                               // 195\n\t  });                                                                                                               // 196\n\t}                                                                                                                   // 197\n\tfunction resolve(self, newValue) {                                                                                  // 198\n\t  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t  if (newValue === self) {                                                                                          // 200\n\t    return reject(                                                                                                  // 201\n\t      self,                                                                                                         // 202\n\t      new TypeError('A promise cannot be resolved with itself.')                                                    // 203\n\t    );                                                                                                              // 204\n\t  }                                                                                                                 // 205\n\t  if (                                                                                                              // 206\n\t    newValue &&                                                                                                     // 207\n\t    (typeof newValue === 'object' || typeof newValue === 'function')                                                // 208\n\t  ) {                                                                                                               // 209\n\t    var then = getThen(newValue);                                                                                   // 210\n\t    if (then === IS_ERROR) {                                                                                        // 211\n\t      return reject(self, LAST_ERROR);                                                                              // 212\n\t    }                                                                                                               // 213\n\t    if (                                                                                                            // 214\n\t      then === self.then &&                                                                                         // 215\n\t      newValue instanceof Promise                                                                                   // 216\n\t    ) {                                                                                                             // 217\n\t      self._37 = 3;                                                                                                 // 218\n\t      self._12 = newValue;                                                                                          // 219\n\t      finale(self);                                                                                                 // 220\n\t      return;                                                                                                       // 221\n\t    } else if (typeof then === 'function') {                                                                        // 222\n\t      doResolve(then.bind(newValue), self);                                                                         // 223\n\t      return;                                                                                                       // 224\n\t    }                                                                                                               // 225\n\t  }                                                                                                                 // 226\n\t  self._37 = 1;                                                                                                     // 227\n\t  self._12 = newValue;                                                                                              // 228\n\t  finale(self);                                                                                                     // 229\n\t}                                                                                                                   // 230\n                                                                                                                     // 231\n\tfunction reject(self, newValue) {                                                                                   // 232\n\t  self._37 = 2;                                                                                                     // 233\n\t  self._12 = newValue;                                                                                              // 234\n\t  finale(self);                                                                                                     // 235\n\t}                                                                                                                   // 236\n\tfunction finale(self) {                                                                                             // 237\n\t  for (var i = 0; i < self._59.length; i++) {                                                                       // 238\n\t    handle(self, self._59[i]);                                                                                      // 239\n\t  }                                                                                                                 // 240\n\t  self._59 = null;                                                                                                  // 241\n\t}                                                                                                                   // 242\n                                                                                                                     // 243\n\tfunction Handler(onFulfilled, onRejected, promise){                                                                 // 244\n\t  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;                                        // 245\n\t  this.onRejected = typeof onRejected === 'function' ? onRejected : null;                                           // 246\n\t  this.promise = promise;                                                                                           // 247\n\t}                                                                                                                   // 248\n                                                                                                                     // 249\n\t/**                                                                                                                 // 250\n\t * Take a potentially misbehaving resolver function and make sure                                                   // 251\n\t * onFulfilled and onRejected are only called once.                                                                 // 252\n\t *                                                                                                                  // 253\n\t * Makes no guarantees about asynchrony.                                                                            // 254\n\t */                                                                                                                 // 255\n\tfunction doResolve(fn, promise) {                                                                                   // 256\n\t  var done = false;                                                                                                 // 257\n\t  var res = tryCallTwo(fn, function (value) {                                                                       // 258\n\t    if (done) return;                                                                                               // 259\n\t    done = true;                                                                                                    // 260\n\t    resolve(promise, value);                                                                                        // 261\n\t  }, function (reason) {                                                                                            // 262\n\t    if (done) return;                                                                                               // 263\n\t    done = true;                                                                                                    // 264\n\t    reject(promise, reason);                                                                                        // 265\n\t  })                                                                                                                // 266\n\t  if (!done && res === IS_ERROR) {                                                                                  // 267\n\t    done = true;                                                                                                    // 268\n\t    reject(promise, LAST_ERROR);                                                                                    // 269\n\t  }                                                                                                                 // 270\n\t}                                                                                                                   // 271\n                                                                                                                     // 272\n                                                                                                                     // 273\n/***/ },                                                                                                             // 274\n/* 3 */                                                                                                              // 275\n/***/ function(module, exports, __webpack_require__) {                                                               // 276\n                                                                                                                     // 277\n\t'use strict';                                                                                                       // 278\n                                                                                                                     // 279\n\tvar Promise = __webpack_require__(2);                                                                               // 280\n                                                                                                                     // 281\n\tmodule.exports = Promise;                                                                                           // 282\n\tPromise.prototype.done = function (onFulfilled, onRejected) {                                                       // 283\n\t  var self = arguments.length ? this.then.apply(this, arguments) : this;                                            // 284\n\t  self.then(null, function (err) {                                                                                  // 285\n\t    setTimeout(function () {                                                                                        // 286\n\t      throw err;                                                                                                    // 287\n\t    }, 0);                                                                                                          // 288\n\t  });                                                                                                               // 289\n\t};                                                                                                                  // 290\n                                                                                                                     // 291\n                                                                                                                     // 292\n/***/ },                                                                                                             // 293\n/* 4 */                                                                                                              // 294\n/***/ function(module, exports, __webpack_require__) {                                                               // 295\n                                                                                                                     // 296\n\t'use strict';                                                                                                       // 297\n                                                                                                                     // 298\n\tvar Promise = __webpack_require__(2);                                                                               // 299\n                                                                                                                     // 300\n\tmodule.exports = Promise;                                                                                           // 301\n\tPromise.prototype['finally'] = function (f) {                                                                       // 302\n\t  return this.then(function (value) {                                                                               // 303\n\t    return Promise.resolve(f()).then(function () {                                                                  // 304\n\t      return value;                                                                                                 // 305\n\t    });                                                                                                             // 306\n\t  }, function (err) {                                                                                               // 307\n\t    return Promise.resolve(f()).then(function () {                                                                  // 308\n\t      throw err;                                                                                                    // 309\n\t    });                                                                                                             // 310\n\t  });                                                                                                               // 311\n\t};                                                                                                                  // 312\n                                                                                                                     // 313\n                                                                                                                     // 314\n/***/ },                                                                                                             // 315\n/* 5 */                                                                                                              // 316\n/***/ function(module, exports, __webpack_require__) {                                                               // 317\n                                                                                                                     // 318\n\t'use strict';                                                                                                       // 319\n                                                                                                                     // 320\n\t//This file contains the ES6 extensions to the core Promises/A+ API                                                 // 321\n                                                                                                                     // 322\n\tvar Promise = __webpack_require__(2);                                                                               // 323\n                                                                                                                     // 324\n\tmodule.exports = Promise;                                                                                           // 325\n                                                                                                                     // 326\n\t/* Static Functions */                                                                                              // 327\n                                                                                                                     // 328\n\tvar TRUE = valuePromise(true);                                                                                      // 329\n\tvar FALSE = valuePromise(false);                                                                                    // 330\n\tvar NULL = valuePromise(null);                                                                                      // 331\n\tvar UNDEFINED = valuePromise(undefined);                                                                            // 332\n\tvar ZERO = valuePromise(0);                                                                                         // 333\n\tvar EMPTYSTRING = valuePromise('');                                                                                 // 334\n                                                                                                                     // 335\n\tfunction valuePromise(value) {                                                                                      // 336\n\t  var p = new Promise(Promise._99);                                                                                 // 337\n\t  p._37 = 1;                                                                                                        // 338\n\t  p._12 = value;                                                                                                    // 339\n\t  return p;                                                                                                         // 340\n\t}                                                                                                                   // 341\n\tPromise.resolve = function (value) {                                                                                // 342\n\t  if (value instanceof Promise) return value;                                                                       // 343\n                                                                                                                     // 344\n\t  if (value === null) return NULL;                                                                                  // 345\n\t  if (value === undefined) return UNDEFINED;                                                                        // 346\n\t  if (value === true) return TRUE;                                                                                  // 347\n\t  if (value === false) return FALSE;                                                                                // 348\n\t  if (value === 0) return ZERO;                                                                                     // 349\n\t  if (value === '') return EMPTYSTRING;                                                                             // 350\n                                                                                                                     // 351\n\t  if (typeof value === 'object' || typeof value === 'function') {                                                   // 352\n\t    try {                                                                                                           // 353\n\t      var then = value.then;                                                                                        // 354\n\t      if (typeof then === 'function') {                                                                             // 355\n\t        return new Promise(then.bind(value));                                                                       // 356\n\t      }                                                                                                             // 357\n\t    } catch (ex) {                                                                                                  // 358\n\t      return new Promise(function (resolve, reject) {                                                               // 359\n\t        reject(ex);                                                                                                 // 360\n\t      });                                                                                                           // 361\n\t    }                                                                                                               // 362\n\t  }                                                                                                                 // 363\n\t  return valuePromise(value);                                                                                       // 364\n\t};                                                                                                                  // 365\n                                                                                                                     // 366\n\tPromise.all = function (arr) {                                                                                      // 367\n\t  var args = Array.prototype.slice.call(arr);                                                                       // 368\n                                                                                                                     // 369\n\t  return new Promise(function (resolve, reject) {                                                                   // 370\n\t    if (args.length === 0) return resolve([]);                                                                      // 371\n\t    var remaining = args.length;                                                                                    // 372\n\t    function res(i, val) {                                                                                          // 373\n\t      if (val && (typeof val === 'object' || typeof val === 'function')) {                                          // 374\n\t        if (val instanceof Promise && val.then === Promise.prototype.then) {                                        // 375\n\t          while (val._37 === 3) {                                                                                   // 376\n\t            val = val._12;                                                                                          // 377\n\t          }                                                                                                         // 378\n\t          if (val._37 === 1) return res(i, val._12);                                                                // 379\n\t          if (val._37 === 2) reject(val._12);                                                                       // 380\n\t          val.then(function (val) {                                                                                 // 381\n\t            res(i, val);                                                                                            // 382\n\t          }, reject);                                                                                               // 383\n\t          return;                                                                                                   // 384\n\t        } else {                                                                                                    // 385\n\t          var then = val.then;                                                                                      // 386\n\t          if (typeof then === 'function') {                                                                         // 387\n\t            var p = new Promise(then.bind(val));                                                                    // 388\n\t            p.then(function (val) {                                                                                 // 389\n\t              res(i, val);                                                                                          // 390\n\t            }, reject);                                                                                             // 391\n\t            return;                                                                                                 // 392\n\t          }                                                                                                         // 393\n\t        }                                                                                                           // 394\n\t      }                                                                                                             // 395\n\t      args[i] = val;                                                                                                // 396\n\t      if (--remaining === 0) {                                                                                      // 397\n\t        resolve(args);                                                                                              // 398\n\t      }                                                                                                             // 399\n\t    }                                                                                                               // 400\n\t    for (var i = 0; i < args.length; i++) {                                                                         // 401\n\t      res(i, args[i]);                                                                                              // 402\n\t    }                                                                                                               // 403\n\t  });                                                                                                               // 404\n\t};                                                                                                                  // 405\n                                                                                                                     // 406\n\tPromise.reject = function (value) {                                                                                 // 407\n\t  return new Promise(function (resolve, reject) {                                                                   // 408\n\t    reject(value);                                                                                                  // 409\n\t  });                                                                                                               // 410\n\t};                                                                                                                  // 411\n                                                                                                                     // 412\n\tPromise.race = function (values) {                                                                                  // 413\n\t  return new Promise(function (resolve, reject) {                                                                   // 414\n\t    values.forEach(function(value){                                                                                 // 415\n\t      Promise.resolve(value).then(resolve, reject);                                                                 // 416\n\t    });                                                                                                             // 417\n\t  });                                                                                                               // 418\n\t};                                                                                                                  // 419\n                                                                                                                     // 420\n\t/* Prototype Methods */                                                                                             // 421\n                                                                                                                     // 422\n\tPromise.prototype['catch'] = function (onRejected) {                                                                // 423\n\t  return this.then(null, onRejected);                                                                               // 424\n\t};                                                                                                                  // 425\n                                                                                                                     // 426\n                                                                                                                     // 427\n/***/ },                                                                                                             // 428\n/* 6 */                                                                                                              // 429\n/***/ function(module, exports, __webpack_require__) {                                                               // 430\n                                                                                                                     // 431\n\t'use strict';                                                                                                       // 432\n                                                                                                                     // 433\n\t// This file contains then/promise specific extensions that are only useful                                         // 434\n\t// for node.js interop                                                                                              // 435\n                                                                                                                     // 436\n\tvar Promise = __webpack_require__(2);                                                                               // 437\n\tvar asap = __webpack_require__(7);                                                                                  // 438\n                                                                                                                     // 439\n\tmodule.exports = Promise;                                                                                           // 440\n                                                                                                                     // 441\n\t/* Static Functions */                                                                                              // 442\n                                                                                                                     // 443\n\tPromise.denodeify = function (fn, argumentCount) {                                                                  // 444\n\t  argumentCount = argumentCount || Infinity;                                                                        // 445\n\t  return function () {                                                                                              // 446\n\t    var self = this;                                                                                                // 447\n\t    var args = Array.prototype.slice.call(arguments, 0,                                                             // 448\n\t        argumentCount > 0 ? argumentCount : 0);                                                                     // 449\n\t    return new Promise(function (resolve, reject) {                                                                 // 450\n\t      args.push(function (err, res) {                                                                               // 451\n\t        if (err) reject(err);                                                                                       // 452\n\t        else resolve(res);                                                                                          // 453\n\t      })                                                                                                            // 454\n\t      var res = fn.apply(self, args);                                                                               // 455\n\t      if (res &&                                                                                                    // 456\n\t        (                                                                                                           // 457\n\t          typeof res === 'object' ||                                                                                // 458\n\t          typeof res === 'function'                                                                                 // 459\n\t        ) &&                                                                                                        // 460\n\t        typeof res.then === 'function'                                                                              // 461\n\t      ) {                                                                                                           // 462\n\t        resolve(res);                                                                                               // 463\n\t      }                                                                                                             // 464\n\t    })                                                                                                              // 465\n\t  }                                                                                                                 // 466\n\t}                                                                                                                   // 467\n\tPromise.nodeify = function (fn) {                                                                                   // 468\n\t  return function () {                                                                                              // 469\n\t    var args = Array.prototype.slice.call(arguments);                                                               // 470\n\t    var callback =                                                                                                  // 471\n\t      typeof args[args.length - 1] === 'function' ? args.pop() : null;                                              // 472\n\t    var ctx = this;                                                                                                 // 473\n\t    try {                                                                                                           // 474\n\t      return fn.apply(this, arguments).nodeify(callback, ctx);                                                      // 475\n\t    } catch (ex) {                                                                                                  // 476\n\t      if (callback === null || typeof callback == 'undefined') {                                                    // 477\n\t        return new Promise(function (resolve, reject) {                                                             // 478\n\t          reject(ex);                                                                                               // 479\n\t        });                                                                                                         // 480\n\t      } else {                                                                                                      // 481\n\t        asap(function () {                                                                                          // 482\n\t          callback.call(ctx, ex);                                                                                   // 483\n\t        })                                                                                                          // 484\n\t      }                                                                                                             // 485\n\t    }                                                                                                               // 486\n\t  }                                                                                                                 // 487\n\t}                                                                                                                   // 488\n                                                                                                                     // 489\n\tPromise.prototype.nodeify = function (callback, ctx) {                                                              // 490\n\t  if (typeof callback != 'function') return this;                                                                   // 491\n                                                                                                                     // 492\n\t  this.then(function (value) {                                                                                      // 493\n\t    asap(function () {                                                                                              // 494\n\t      callback.call(ctx, null, value);                                                                              // 495\n\t    });                                                                                                             // 496\n\t  }, function (err) {                                                                                               // 497\n\t    asap(function () {                                                                                              // 498\n\t      callback.call(ctx, err);                                                                                      // 499\n\t    });                                                                                                             // 500\n\t  });                                                                                                               // 501\n\t}                                                                                                                   // 502\n                                                                                                                     // 503\n                                                                                                                     // 504\n/***/ },                                                                                                             // 505\n/* 7 */                                                                                                              // 506\n/***/ function(module, exports, __webpack_require__) {                                                               // 507\n                                                                                                                     // 508\n\t\"use strict\";                                                                                                       // 509\n                                                                                                                     // 510\n\t// rawAsap provides everything we need except exception management.                                                 // 511\n\tvar rawAsap = __webpack_require__(8);                                                                               // 512\n\t// RawTasks are recycled to reduce GC churn.                                                                        // 513\n\tvar freeTasks = [];                                                                                                 // 514\n\t// We queue errors to ensure they are thrown in right order (FIFO).                                                 // 515\n\t// Array-as-queue is good enough here, since we are just dealing with exceptions.                                   // 516\n\tvar pendingErrors = [];                                                                                             // 517\n\tvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);                                          // 518\n                                                                                                                     // 519\n\tfunction throwFirstError() {                                                                                        // 520\n\t    if (pendingErrors.length) {                                                                                     // 521\n\t        throw pendingErrors.shift();                                                                                // 522\n\t    }                                                                                                               // 523\n\t}                                                                                                                   // 524\n                                                                                                                     // 525\n\t/**                                                                                                                 // 526\n\t * Calls a task as soon as possible after returning, in its own event, with priority                                // 527\n\t * over other events like animation, reflow, and repaint. An error thrown from an                                   // 528\n\t * event will not interrupt, nor even substantially slow down the processing of                                     // 529\n\t * other events, but will be rather postponed to a lower priority event.                                            // 530\n\t * @param {{call}} task A callable object, typically a function that takes no                                       // 531\n\t * arguments.                                                                                                       // 532\n\t */                                                                                                                 // 533\n\tmodule.exports = asap;                                                                                              // 534\n\tfunction asap(task) {                                                                                               // 535\n\t    var rawTask;                                                                                                    // 536\n\t    if (freeTasks.length) {                                                                                         // 537\n\t        rawTask = freeTasks.pop();                                                                                  // 538\n\t    } else {                                                                                                        // 539\n\t        rawTask = new RawTask();                                                                                    // 540\n\t    }                                                                                                               // 541\n\t    rawTask.task = task;                                                                                            // 542\n\t    rawAsap(rawTask);                                                                                               // 543\n\t}                                                                                                                   // 544\n                                                                                                                     // 545\n\t// We wrap tasks with recyclable task objects.  A task object implements                                            // 546\n\t// `call`, just like a function.                                                                                    // 547\n\tfunction RawTask() {                                                                                                // 548\n\t    this.task = null;                                                                                               // 549\n\t}                                                                                                                   // 550\n                                                                                                                     // 551\n\t// The sole purpose of wrapping the task is to catch the exception and recycle                                      // 552\n\t// the task object after its single use.                                                                            // 553\n\tRawTask.prototype.call = function () {                                                                              // 554\n\t    try {                                                                                                           // 555\n\t        this.task.call();                                                                                           // 556\n\t    } catch (error) {                                                                                               // 557\n\t        if (asap.onerror) {                                                                                         // 558\n\t            // This hook exists purely for testing purposes.                                                        // 559\n\t            // Its name will be periodically randomized to break any code that                                      // 560\n\t            // depends on its existence.                                                                            // 561\n\t            asap.onerror(error);                                                                                    // 562\n\t        } else {                                                                                                    // 563\n\t            // In a web browser, exceptions are not fatal. However, to avoid                                        // 564\n\t            // slowing down the queue of pending tasks, we rethrow the error in a                                   // 565\n\t            // lower priority turn.                                                                                 // 566\n\t            pendingErrors.push(error);                                                                              // 567\n\t            requestErrorThrow();                                                                                    // 568\n\t        }                                                                                                           // 569\n\t    } finally {                                                                                                     // 570\n\t        this.task = null;                                                                                           // 571\n\t        freeTasks[freeTasks.length] = this;                                                                         // 572\n\t    }                                                                                                               // 573\n\t};                                                                                                                  // 574\n                                                                                                                     // 575\n                                                                                                                     // 576\n/***/ },                                                                                                             // 577\n/* 8 */                                                                                                              // 578\n/***/ function(module, exports, __webpack_require__) {                                                               // 579\n                                                                                                                     // 580\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";                                                         // 581\n                                                                                                                     // 582\n\t// Use the fastest means possible to execute a task in its own turn, with                                           // 583\n\t// priority over other events including IO, animation, reflow, and redraw                                           // 584\n\t// events in browsers.                                                                                              // 585\n\t//                                                                                                                  // 586\n\t// An exception thrown by a task will permanently interrupt the processing of                                       // 587\n\t// subsequent tasks. The higher level `asap` function ensures that if an                                            // 588\n\t// exception is thrown by a task, that the task queue will continue flushing as                                     // 589\n\t// soon as possible, but if you use `rawAsap` directly, you are responsible to                                      // 590\n\t// either ensure that no exceptions are thrown from your task, or to manually                                       // 591\n\t// call `rawAsap.requestFlush` if an exception is thrown.                                                           // 592\n\tmodule.exports = rawAsap;                                                                                           // 593\n\tfunction rawAsap(task) {                                                                                            // 594\n\t    if (!queue.length) {                                                                                            // 595\n\t        requestFlush();                                                                                             // 596\n\t        flushing = true;                                                                                            // 597\n\t    }                                                                                                               // 598\n\t    // Equivalent to push, but avoids a function call.                                                              // 599\n\t    queue[queue.length] = task;                                                                                     // 600\n\t}                                                                                                                   // 601\n                                                                                                                     // 602\n\tvar queue = [];                                                                                                     // 603\n\t// Once a flush has been requested, no further calls to `requestFlush` are                                          // 604\n\t// necessary until the next `flush` completes.                                                                      // 605\n\tvar flushing = false;                                                                                               // 606\n\t// `requestFlush` is an implementation-specific method that attempts to kick                                        // 607\n\t// off a `flush` event as quickly as possible. `flush` will attempt to exhaust                                      // 608\n\t// the event queue before yielding to the browser's own event loop.                                                 // 609\n\tvar requestFlush;                                                                                                   // 610\n\t// The position of the next task to execute in the task queue. This is                                              // 611\n\t// preserved between calls to `flush` so that it can be resumed if                                                  // 612\n\t// a task throws an exception.                                                                                      // 613\n\tvar index = 0;                                                                                                      // 614\n\t// If a task schedules additional tasks recursively, the task queue can grow                                        // 615\n\t// unbounded. To prevent memory exhaustion, the task queue will periodically                                        // 616\n\t// truncate already-completed tasks.                                                                                // 617\n\tvar capacity = 1024;                                                                                                // 618\n                                                                                                                     // 619\n\t// The flush function processes all tasks that have been scheduled with                                             // 620\n\t// `rawAsap` unless and until one of those tasks throws an exception.                                               // 621\n\t// If a task throws an exception, `flush` ensures that its state will remain                                        // 622\n\t// consistent and will resume where it left off when called again.                                                  // 623\n\t// However, `flush` does not make any arrangements to be called again if an                                         // 624\n\t// exception is thrown.                                                                                             // 625\n\tfunction flush() {                                                                                                  // 626\n\t    while (index < queue.length) {                                                                                  // 627\n\t        var currentIndex = index;                                                                                   // 628\n\t        // Advance the index before calling the task. This ensures that we will                                     // 629\n\t        // begin flushing on the next task the task throws an error.                                                // 630\n\t        index = index + 1;                                                                                          // 631\n\t        queue[currentIndex].call();                                                                                 // 632\n\t        // Prevent leaking memory for long chains of recursive calls to `asap`.                                     // 633\n\t        // If we call `asap` within tasks scheduled by `asap`, the queue will                                       // 634\n\t        // grow, but to avoid an O(n) walk for every task we execute, we don't                                      // 635\n\t        // shift tasks off the queue after they have been executed.                                                 // 636\n\t        // Instead, we periodically shift 1024 tasks off the queue.                                                 // 637\n\t        if (index > capacity) {                                                                                     // 638\n\t            // Manually shift all values starting at the index back to the                                          // 639\n\t            // beginning of the queue.                                                                              // 640\n\t            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {                        // 641\n\t                queue[scan] = queue[scan + index];                                                                  // 642\n\t            }                                                                                                       // 643\n\t            queue.length -= index;                                                                                  // 644\n\t            index = 0;                                                                                              // 645\n\t        }                                                                                                           // 646\n\t    }                                                                                                               // 647\n\t    queue.length = 0;                                                                                               // 648\n\t    index = 0;                                                                                                      // 649\n\t    flushing = false;                                                                                               // 650\n\t}                                                                                                                   // 651\n                                                                                                                     // 652\n\t// `requestFlush` is implemented using a strategy based on data collected from                                      // 653\n\t// every available SauceLabs Selenium web driver worker at time of writing.                                         // 654\n\t// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593           // 655\n                                                                                                                     // 656\n\t// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that                                        // 657\n\t// have WebKitMutationObserver but not un-prefixed MutationObserver.                                                // 658\n\t// Must use `global` instead of `window` to work in both frames and web                                             // 659\n\t// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.                                                 // 660\n\tvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;                             // 661\n                                                                                                                     // 662\n\t// MutationObservers are desirable because they have high priority and work                                         // 663\n\t// reliably everywhere they are implemented.                                                                        // 664\n\t// They are implemented in all modern browsers.                                                                     // 665\n\t//                                                                                                                  // 666\n\t// - Android 4-4.3                                                                                                  // 667\n\t// - Chrome 26-34                                                                                                   // 668\n\t// - Firefox 14-29                                                                                                  // 669\n\t// - Internet Explorer 11                                                                                           // 670\n\t// - iPad Safari 6-7.1                                                                                              // 671\n\t// - iPhone Safari 7-7.1                                                                                            // 672\n\t// - Safari 6-7                                                                                                     // 673\n\tif (typeof BrowserMutationObserver === \"function\") {                                                                // 674\n\t    requestFlush = makeRequestCallFromMutationObserver(flush);                                                      // 675\n                                                                                                                     // 676\n\t// MessageChannels are desirable because they give direct access to the HTML                                        // 677\n\t// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera                                     // 678\n\t// 11-12, and in web workers in many engines.                                                                       // 679\n\t// Although message channels yield to any queued rendering and IO tasks, they                                       // 680\n\t// would be better than imposing the 4ms delay of timers.                                                           // 681\n\t// However, they do not work reliably in Internet Explorer or Safari.                                               // 682\n                                                                                                                     // 683\n\t// Internet Explorer 10 is the only browser that has setImmediate but does                                          // 684\n\t// not have MutationObservers.                                                                                      // 685\n\t// Although setImmediate yields to the browser's renderer, it would be                                              // 686\n\t// preferrable to falling back to setTimeout since it does not have                                                 // 687\n\t// the minimum 4ms penalty.                                                                                         // 688\n\t// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and                                      // 689\n\t// Desktop to a lesser extent) that renders both setImmediate and                                                   // 690\n\t// MessageChannel useless for the purposes of ASAP.                                                                 // 691\n\t// https://github.com/kriskowal/q/issues/396                                                                        // 692\n                                                                                                                     // 693\n\t// Timers are implemented universally.                                                                              // 694\n\t// We fall back to timers in workers in most engines, and in foreground                                             // 695\n\t// contexts in the following browsers.                                                                              // 696\n\t// However, note that even this simple case requires nuances to operate in a                                        // 697\n\t// broad spectrum of browsers.                                                                                      // 698\n\t//                                                                                                                  // 699\n\t// - Firefox 3-13                                                                                                   // 700\n\t// - Internet Explorer 6-9                                                                                          // 701\n\t// - iPad Safari 4.3                                                                                                // 702\n\t// - Lynx 2.8.7                                                                                                     // 703\n\t} else {                                                                                                            // 704\n\t    requestFlush = makeRequestCallFromTimer(flush);                                                                 // 705\n\t}                                                                                                                   // 706\n                                                                                                                     // 707\n\t// `requestFlush` requests that the high priority event queue be flushed as                                         // 708\n\t// soon as possible.                                                                                                // 709\n\t// This is useful to prevent an error thrown in a task from stalling the event                                      // 710\n\t// queue if the exception handled by Node.jss                                                                      // 711\n\t// `process.on(\"uncaughtException\")` or by a domain.                                                                // 712\n\trawAsap.requestFlush = requestFlush;                                                                                // 713\n                                                                                                                     // 714\n\t// To request a high priority event, we induce a mutation observer by toggling                                      // 715\n\t// the text of a text node between \"1\" and \"-1\".                                                                    // 716\n\tfunction makeRequestCallFromMutationObserver(callback) {                                                            // 717\n\t    var toggle = 1;                                                                                                 // 718\n\t    var observer = new BrowserMutationObserver(callback);                                                           // 719\n\t    var node = document.createTextNode(\"\");                                                                         // 720\n\t    observer.observe(node, {characterData: true});                                                                  // 721\n\t    return function requestCall() {                                                                                 // 722\n\t        toggle = -toggle;                                                                                           // 723\n\t        node.data = toggle;                                                                                         // 724\n\t    };                                                                                                              // 725\n\t}                                                                                                                   // 726\n                                                                                                                     // 727\n\t// The message channel technique was discovered by Malte Ubl and was the                                            // 728\n\t// original foundation for this library.                                                                            // 729\n\t// http://www.nonblocking.io/2011/06/windownexttick.html                                                            // 730\n                                                                                                                     // 731\n\t// Safari 6.0.5 (at least) intermittently fails to create message ports on a                                        // 732\n\t// page's first load. Thankfully, this version of Safari supports                                                   // 733\n\t// MutationObservers, so we don't need to fall back in that case.                                                   // 734\n                                                                                                                     // 735\n\t// function makeRequestCallFromMessageChannel(callback) {                                                           // 736\n\t//     var channel = new MessageChannel();                                                                          // 737\n\t//     channel.port1.onmessage = callback;                                                                          // 738\n\t//     return function requestCall() {                                                                              // 739\n\t//         channel.port2.postMessage(0);                                                                            // 740\n\t//     };                                                                                                           // 741\n\t// }                                                                                                                // 742\n                                                                                                                     // 743\n\t// For reasons explained above, we are also unable to use `setImmediate`                                            // 744\n\t// under any circumstances.                                                                                         // 745\n\t// Even if we were, there is another bug in Internet Explorer 10.                                                   // 746\n\t// It is not sufficient to assign `setImmediate` to `requestFlush` because                                          // 747\n\t// `setImmediate` must be called *by name* and therefore must be wrapped in a                                       // 748\n\t// closure.                                                                                                         // 749\n\t// Never forget.                                                                                                    // 750\n                                                                                                                     // 751\n\t// function makeRequestCallFromSetImmediate(callback) {                                                             // 752\n\t//     return function requestCall() {                                                                              // 753\n\t//         setImmediate(callback);                                                                                  // 754\n\t//     };                                                                                                           // 755\n\t// }                                                                                                                // 756\n                                                                                                                     // 757\n\t// Safari 6.0 has a problem where timers will get lost while the user is                                            // 758\n\t// scrolling. This problem does not impact ASAP because Safari 6.0 supports                                         // 759\n\t// mutation observers, so that implementation is used instead.                                                      // 760\n\t// However, if we ever elect to use timers in Safari, the prevalent work-around                                     // 761\n\t// is to add a scroll event listener that calls for a flush.                                                        // 762\n                                                                                                                     // 763\n\t// `setTimeout` does not call the passed callback if the delay is less than                                         // 764\n\t// approximately 7 in web workers in Firefox 8 through 18, and sometimes not                                        // 765\n\t// even then.                                                                                                       // 766\n                                                                                                                     // 767\n\tfunction makeRequestCallFromTimer(callback) {                                                                       // 768\n\t    return function requestCall() {                                                                                 // 769\n\t        // We dispatch a timeout with a specified delay of 0 for engines that                                       // 770\n\t        // can reliably accommodate that request. This will usually be snapped                                      // 771\n\t        // to a 4 milisecond delay, but once we're flushing, there's no delay                                       // 772\n\t        // between events.                                                                                          // 773\n\t        var timeoutHandle = setTimeout(handleTimer, 0);                                                             // 774\n\t        // However, since this timer gets frequently dropped in Firefox                                             // 775\n\t        // workers, we enlist an interval handle that will try to fire                                              // 776\n\t        // an event 20 times per second until it succeeds.                                                          // 777\n\t        var intervalHandle = setInterval(handleTimer, 50);                                                          // 778\n                                                                                                                     // 779\n\t        function handleTimer() {                                                                                    // 780\n\t            // Whichever timer succeeds will cancel both timers and                                                 // 781\n\t            // execute the callback.                                                                                // 782\n\t            clearTimeout(timeoutHandle);                                                                            // 783\n\t            clearInterval(intervalHandle);                                                                          // 784\n\t            callback();                                                                                             // 785\n\t        }                                                                                                           // 786\n\t    };                                                                                                              // 787\n\t}                                                                                                                   // 788\n                                                                                                                     // 789\n\t// This is for `asap.js` only.                                                                                      // 790\n\t// Its name will be periodically randomized to break any code that depends on                                       // 791\n\t// its existence.                                                                                                   // 792\n\trawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;                                                        // 793\n                                                                                                                     // 794\n\t// ASAP was originally a nextTick shim included in Q. This was factored out                                         // 795\n\t// into this ASAP package. It was later adapted to RSVP which made further                                          // 796\n\t// amendments. These decisions, particularly to marginalize MessageChannel and                                      // 797\n\t// to capture the MutationObserver implementation in a closure, were integrated                                     // 798\n\t// back into ASAP proper.                                                                                           // 799\n\t// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js                // 800\n                                                                                                                     // 801\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))                                        // 802\n                                                                                                                     // 803\n/***/ }                                                                                                              // 804\n/******/ ]);                                                                                                         // 805\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage.promise = {\n  Promise: Promise\n};\n\n})();\n","servePath":"/packages/promise.js","sourceMap":{"version":3,"sources":["/packages/promise/.npm/package/node_modules/meteor-promise/promise.bundle.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H","file":"/packages/promise.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// See https://github.com/then/promise#usage for an explanation of why we\n\t// require promise/domains here.\n\tvar MeteorPromise = __webpack_require__(1);\n\n\tvar es6PromiseThen = MeteorPromise.prototype.then;\n\tMeteorPromise.prototype.then = function (onResolved, onRejected) {\n\t  if (typeof Meteor === \"object\" &&\n\t      typeof Meteor.bindEnvironment === \"function\") {\n\t    return es6PromiseThen.call(\n\t      this,\n\t      onResolved && Meteor.bindEnvironment(onResolved, raise),\n\t      onRejected && Meteor.bindEnvironment(onRejected, raise)\n\t    );\n\t  }\n\t  return es6PromiseThen.call(this, onResolved, onRejected);\n\t};\n\n\tfunction raise(exception) {\n\t  throw exception;\n\t}\n\n\tPromise = MeteorPromise;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tmodule.exports = __webpack_require__(2);\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\t__webpack_require__(6);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar asap = __webpack_require__(7);\n\n\tfunction noop() {}\n\n\t// States:\n\t//\n\t// 0 - pending\n\t// 1 - fulfilled with _value\n\t// 2 - rejected with _value\n\t// 3 - adopted the state of another promise, _value\n\t//\n\t// once the state is no longer pending (0) it is immutable\n\n\t// All `_` prefixed properties will be reduced to `_{random number}`\n\t// at build time to obfuscate them and discourage their use.\n\t// We don't use symbols or Object.defineProperty to fully hide them\n\t// because the performance isn't good enough.\n\n\n\t// to avoid using try/catch inside critical functions, we\n\t// extract them to here.\n\tvar LAST_ERROR = null;\n\tvar IS_ERROR = {};\n\tfunction getThen(obj) {\n\t  try {\n\t    return obj.then;\n\t  } catch (ex) {\n\t    LAST_ERROR = ex;\n\t    return IS_ERROR;\n\t  }\n\t}\n\n\tfunction tryCallOne(fn, a) {\n\t  try {\n\t    return fn(a);\n\t  } catch (ex) {\n\t    LAST_ERROR = ex;\n\t    return IS_ERROR;\n\t  }\n\t}\n\tfunction tryCallTwo(fn, a, b) {\n\t  try {\n\t    fn(a, b);\n\t  } catch (ex) {\n\t    LAST_ERROR = ex;\n\t    return IS_ERROR;\n\t  }\n\t}\n\n\tmodule.exports = Promise;\n\n\tfunction Promise(fn) {\n\t  if (typeof this !== 'object') {\n\t    throw new TypeError('Promises must be constructed via new');\n\t  }\n\t  if (typeof fn !== 'function') {\n\t    throw new TypeError('not a function');\n\t  }\n\t  this._37 = 0;\n\t  this._12 = null;\n\t  this._59 = [];\n\t  if (fn === noop) return;\n\t  doResolve(fn, this);\n\t}\n\tPromise._99 = noop;\n\n\tPromise.prototype.then = function(onFulfilled, onRejected) {\n\t  if (this.constructor !== Promise) {\n\t    return safeThen(this, onFulfilled, onRejected);\n\t  }\n\t  var res = new Promise(noop);\n\t  handle(this, new Handler(onFulfilled, onRejected, res));\n\t  return res;\n\t};\n\n\tfunction safeThen(self, onFulfilled, onRejected) {\n\t  return new self.constructor(function (resolve, reject) {\n\t    var res = new Promise(noop);\n\t    res.then(resolve, reject);\n\t    handle(self, new Handler(onFulfilled, onRejected, res));\n\t  });\n\t};\n\tfunction handle(self, deferred) {\n\t  while (self._37 === 3) {\n\t    self = self._12;\n\t  }\n\t  if (self._37 === 0) {\n\t    self._59.push(deferred);\n\t    return;\n\t  }\n\t  asap(function() {\n\t    var cb = self._37 === 1 ? deferred.onFulfilled : deferred.onRejected;\n\t    if (cb === null) {\n\t      if (self._37 === 1) {\n\t        resolve(deferred.promise, self._12);\n\t      } else {\n\t        reject(deferred.promise, self._12);\n\t      }\n\t      return;\n\t    }\n\t    var ret = tryCallOne(cb, self._12);\n\t    if (ret === IS_ERROR) {\n\t      reject(deferred.promise, LAST_ERROR);\n\t    } else {\n\t      resolve(deferred.promise, ret);\n\t    }\n\t  });\n\t}\n\tfunction resolve(self, newValue) {\n\t  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t  if (newValue === self) {\n\t    return reject(\n\t      self,\n\t      new TypeError('A promise cannot be resolved with itself.')\n\t    );\n\t  }\n\t  if (\n\t    newValue &&\n\t    (typeof newValue === 'object' || typeof newValue === 'function')\n\t  ) {\n\t    var then = getThen(newValue);\n\t    if (then === IS_ERROR) {\n\t      return reject(self, LAST_ERROR);\n\t    }\n\t    if (\n\t      then === self.then &&\n\t      newValue instanceof Promise\n\t    ) {\n\t      self._37 = 3;\n\t      self._12 = newValue;\n\t      finale(self);\n\t      return;\n\t    } else if (typeof then === 'function') {\n\t      doResolve(then.bind(newValue), self);\n\t      return;\n\t    }\n\t  }\n\t  self._37 = 1;\n\t  self._12 = newValue;\n\t  finale(self);\n\t}\n\n\tfunction reject(self, newValue) {\n\t  self._37 = 2;\n\t  self._12 = newValue;\n\t  finale(self);\n\t}\n\tfunction finale(self) {\n\t  for (var i = 0; i < self._59.length; i++) {\n\t    handle(self, self._59[i]);\n\t  }\n\t  self._59 = null;\n\t}\n\n\tfunction Handler(onFulfilled, onRejected, promise){\n\t  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t  this.promise = promise;\n\t}\n\n\t/**\n\t * Take a potentially misbehaving resolver function and make sure\n\t * onFulfilled and onRejected are only called once.\n\t *\n\t * Makes no guarantees about asynchrony.\n\t */\n\tfunction doResolve(fn, promise) {\n\t  var done = false;\n\t  var res = tryCallTwo(fn, function (value) {\n\t    if (done) return;\n\t    done = true;\n\t    resolve(promise, value);\n\t  }, function (reason) {\n\t    if (done) return;\n\t    done = true;\n\t    reject(promise, reason);\n\t  })\n\t  if (!done && res === IS_ERROR) {\n\t    done = true;\n\t    reject(promise, LAST_ERROR);\n\t  }\n\t}\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Promise = __webpack_require__(2);\n\n\tmodule.exports = Promise;\n\tPromise.prototype.done = function (onFulfilled, onRejected) {\n\t  var self = arguments.length ? this.then.apply(this, arguments) : this;\n\t  self.then(null, function (err) {\n\t    setTimeout(function () {\n\t      throw err;\n\t    }, 0);\n\t  });\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar Promise = __webpack_require__(2);\n\n\tmodule.exports = Promise;\n\tPromise.prototype['finally'] = function (f) {\n\t  return this.then(function (value) {\n\t    return Promise.resolve(f()).then(function () {\n\t      return value;\n\t    });\n\t  }, function (err) {\n\t    return Promise.resolve(f()).then(function () {\n\t      throw err;\n\t    });\n\t  });\n\t};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\t//This file contains the ES6 extensions to the core Promises/A+ API\n\n\tvar Promise = __webpack_require__(2);\n\n\tmodule.exports = Promise;\n\n\t/* Static Functions */\n\n\tvar TRUE = valuePromise(true);\n\tvar FALSE = valuePromise(false);\n\tvar NULL = valuePromise(null);\n\tvar UNDEFINED = valuePromise(undefined);\n\tvar ZERO = valuePromise(0);\n\tvar EMPTYSTRING = valuePromise('');\n\n\tfunction valuePromise(value) {\n\t  var p = new Promise(Promise._99);\n\t  p._37 = 1;\n\t  p._12 = value;\n\t  return p;\n\t}\n\tPromise.resolve = function (value) {\n\t  if (value instanceof Promise) return value;\n\n\t  if (value === null) return NULL;\n\t  if (value === undefined) return UNDEFINED;\n\t  if (value === true) return TRUE;\n\t  if (value === false) return FALSE;\n\t  if (value === 0) return ZERO;\n\t  if (value === '') return EMPTYSTRING;\n\n\t  if (typeof value === 'object' || typeof value === 'function') {\n\t    try {\n\t      var then = value.then;\n\t      if (typeof then === 'function') {\n\t        return new Promise(then.bind(value));\n\t      }\n\t    } catch (ex) {\n\t      return new Promise(function (resolve, reject) {\n\t        reject(ex);\n\t      });\n\t    }\n\t  }\n\t  return valuePromise(value);\n\t};\n\n\tPromise.all = function (arr) {\n\t  var args = Array.prototype.slice.call(arr);\n\n\t  return new Promise(function (resolve, reject) {\n\t    if (args.length === 0) return resolve([]);\n\t    var remaining = args.length;\n\t    function res(i, val) {\n\t      if (val && (typeof val === 'object' || typeof val === 'function')) {\n\t        if (val instanceof Promise && val.then === Promise.prototype.then) {\n\t          while (val._37 === 3) {\n\t            val = val._12;\n\t          }\n\t          if (val._37 === 1) return res(i, val._12);\n\t          if (val._37 === 2) reject(val._12);\n\t          val.then(function (val) {\n\t            res(i, val);\n\t          }, reject);\n\t          return;\n\t        } else {\n\t          var then = val.then;\n\t          if (typeof then === 'function') {\n\t            var p = new Promise(then.bind(val));\n\t            p.then(function (val) {\n\t              res(i, val);\n\t            }, reject);\n\t            return;\n\t          }\n\t        }\n\t      }\n\t      args[i] = val;\n\t      if (--remaining === 0) {\n\t        resolve(args);\n\t      }\n\t    }\n\t    for (var i = 0; i < args.length; i++) {\n\t      res(i, args[i]);\n\t    }\n\t  });\n\t};\n\n\tPromise.reject = function (value) {\n\t  return new Promise(function (resolve, reject) {\n\t    reject(value);\n\t  });\n\t};\n\n\tPromise.race = function (values) {\n\t  return new Promise(function (resolve, reject) {\n\t    values.forEach(function(value){\n\t      Promise.resolve(value).then(resolve, reject);\n\t    });\n\t  });\n\t};\n\n\t/* Prototype Methods */\n\n\tPromise.prototype['catch'] = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\t// This file contains then/promise specific extensions that are only useful\n\t// for node.js interop\n\n\tvar Promise = __webpack_require__(2);\n\tvar asap = __webpack_require__(7);\n\n\tmodule.exports = Promise;\n\n\t/* Static Functions */\n\n\tPromise.denodeify = function (fn, argumentCount) {\n\t  argumentCount = argumentCount || Infinity;\n\t  return function () {\n\t    var self = this;\n\t    var args = Array.prototype.slice.call(arguments, 0,\n\t        argumentCount > 0 ? argumentCount : 0);\n\t    return new Promise(function (resolve, reject) {\n\t      args.push(function (err, res) {\n\t        if (err) reject(err);\n\t        else resolve(res);\n\t      })\n\t      var res = fn.apply(self, args);\n\t      if (res &&\n\t        (\n\t          typeof res === 'object' ||\n\t          typeof res === 'function'\n\t        ) &&\n\t        typeof res.then === 'function'\n\t      ) {\n\t        resolve(res);\n\t      }\n\t    })\n\t  }\n\t}\n\tPromise.nodeify = function (fn) {\n\t  return function () {\n\t    var args = Array.prototype.slice.call(arguments);\n\t    var callback =\n\t      typeof args[args.length - 1] === 'function' ? args.pop() : null;\n\t    var ctx = this;\n\t    try {\n\t      return fn.apply(this, arguments).nodeify(callback, ctx);\n\t    } catch (ex) {\n\t      if (callback === null || typeof callback == 'undefined') {\n\t        return new Promise(function (resolve, reject) {\n\t          reject(ex);\n\t        });\n\t      } else {\n\t        asap(function () {\n\t          callback.call(ctx, ex);\n\t        })\n\t      }\n\t    }\n\t  }\n\t}\n\n\tPromise.prototype.nodeify = function (callback, ctx) {\n\t  if (typeof callback != 'function') return this;\n\n\t  this.then(function (value) {\n\t    asap(function () {\n\t      callback.call(ctx, null, value);\n\t    });\n\t  }, function (err) {\n\t    asap(function () {\n\t      callback.call(ctx, err);\n\t    });\n\t  });\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\n\t// rawAsap provides everything we need except exception management.\n\tvar rawAsap = __webpack_require__(8);\n\t// RawTasks are recycled to reduce GC churn.\n\tvar freeTasks = [];\n\t// We queue errors to ensure they are thrown in right order (FIFO).\n\t// Array-as-queue is good enough here, since we are just dealing with exceptions.\n\tvar pendingErrors = [];\n\tvar requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);\n\n\tfunction throwFirstError() {\n\t    if (pendingErrors.length) {\n\t        throw pendingErrors.shift();\n\t    }\n\t}\n\n\t/**\n\t * Calls a task as soon as possible after returning, in its own event, with priority\n\t * over other events like animation, reflow, and repaint. An error thrown from an\n\t * event will not interrupt, nor even substantially slow down the processing of\n\t * other events, but will be rather postponed to a lower priority event.\n\t * @param {{call}} task A callable object, typically a function that takes no\n\t * arguments.\n\t */\n\tmodule.exports = asap;\n\tfunction asap(task) {\n\t    var rawTask;\n\t    if (freeTasks.length) {\n\t        rawTask = freeTasks.pop();\n\t    } else {\n\t        rawTask = new RawTask();\n\t    }\n\t    rawTask.task = task;\n\t    rawAsap(rawTask);\n\t}\n\n\t// We wrap tasks with recyclable task objects.  A task object implements\n\t// `call`, just like a function.\n\tfunction RawTask() {\n\t    this.task = null;\n\t}\n\n\t// The sole purpose of wrapping the task is to catch the exception and recycle\n\t// the task object after its single use.\n\tRawTask.prototype.call = function () {\n\t    try {\n\t        this.task.call();\n\t    } catch (error) {\n\t        if (asap.onerror) {\n\t            // This hook exists purely for testing purposes.\n\t            // Its name will be periodically randomized to break any code that\n\t            // depends on its existence.\n\t            asap.onerror(error);\n\t        } else {\n\t            // In a web browser, exceptions are not fatal. However, to avoid\n\t            // slowing down the queue of pending tasks, we rethrow the error in a\n\t            // lower priority turn.\n\t            pendingErrors.push(error);\n\t            requestErrorThrow();\n\t        }\n\t    } finally {\n\t        this.task = null;\n\t        freeTasks[freeTasks.length] = this;\n\t    }\n\t};\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\n\t// Use the fastest means possible to execute a task in its own turn, with\n\t// priority over other events including IO, animation, reflow, and redraw\n\t// events in browsers.\n\t//\n\t// An exception thrown by a task will permanently interrupt the processing of\n\t// subsequent tasks. The higher level `asap` function ensures that if an\n\t// exception is thrown by a task, that the task queue will continue flushing as\n\t// soon as possible, but if you use `rawAsap` directly, you are responsible to\n\t// either ensure that no exceptions are thrown from your task, or to manually\n\t// call `rawAsap.requestFlush` if an exception is thrown.\n\tmodule.exports = rawAsap;\n\tfunction rawAsap(task) {\n\t    if (!queue.length) {\n\t        requestFlush();\n\t        flushing = true;\n\t    }\n\t    // Equivalent to push, but avoids a function call.\n\t    queue[queue.length] = task;\n\t}\n\n\tvar queue = [];\n\t// Once a flush has been requested, no further calls to `requestFlush` are\n\t// necessary until the next `flush` completes.\n\tvar flushing = false;\n\t// `requestFlush` is an implementation-specific method that attempts to kick\n\t// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n\t// the event queue before yielding to the browser's own event loop.\n\tvar requestFlush;\n\t// The position of the next task to execute in the task queue. This is\n\t// preserved between calls to `flush` so that it can be resumed if\n\t// a task throws an exception.\n\tvar index = 0;\n\t// If a task schedules additional tasks recursively, the task queue can grow\n\t// unbounded. To prevent memory exhaustion, the task queue will periodically\n\t// truncate already-completed tasks.\n\tvar capacity = 1024;\n\n\t// The flush function processes all tasks that have been scheduled with\n\t// `rawAsap` unless and until one of those tasks throws an exception.\n\t// If a task throws an exception, `flush` ensures that its state will remain\n\t// consistent and will resume where it left off when called again.\n\t// However, `flush` does not make any arrangements to be called again if an\n\t// exception is thrown.\n\tfunction flush() {\n\t    while (index < queue.length) {\n\t        var currentIndex = index;\n\t        // Advance the index before calling the task. This ensures that we will\n\t        // begin flushing on the next task the task throws an error.\n\t        index = index + 1;\n\t        queue[currentIndex].call();\n\t        // Prevent leaking memory for long chains of recursive calls to `asap`.\n\t        // If we call `asap` within tasks scheduled by `asap`, the queue will\n\t        // grow, but to avoid an O(n) walk for every task we execute, we don't\n\t        // shift tasks off the queue after they have been executed.\n\t        // Instead, we periodically shift 1024 tasks off the queue.\n\t        if (index > capacity) {\n\t            // Manually shift all values starting at the index back to the\n\t            // beginning of the queue.\n\t            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n\t                queue[scan] = queue[scan + index];\n\t            }\n\t            queue.length -= index;\n\t            index = 0;\n\t        }\n\t    }\n\t    queue.length = 0;\n\t    index = 0;\n\t    flushing = false;\n\t}\n\n\t// `requestFlush` is implemented using a strategy based on data collected from\n\t// every available SauceLabs Selenium web driver worker at time of writing.\n\t// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n\t// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n\t// have WebKitMutationObserver but not un-prefixed MutationObserver.\n\t// Must use `global` instead of `window` to work in both frames and web\n\t// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\tvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\n\t// MutationObservers are desirable because they have high priority and work\n\t// reliably everywhere they are implemented.\n\t// They are implemented in all modern browsers.\n\t//\n\t// - Android 4-4.3\n\t// - Chrome 26-34\n\t// - Firefox 14-29\n\t// - Internet Explorer 11\n\t// - iPad Safari 6-7.1\n\t// - iPhone Safari 7-7.1\n\t// - Safari 6-7\n\tif (typeof BrowserMutationObserver === \"function\") {\n\t    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n\t// MessageChannels are desirable because they give direct access to the HTML\n\t// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n\t// 11-12, and in web workers in many engines.\n\t// Although message channels yield to any queued rendering and IO tasks, they\n\t// would be better than imposing the 4ms delay of timers.\n\t// However, they do not work reliably in Internet Explorer or Safari.\n\n\t// Internet Explorer 10 is the only browser that has setImmediate but does\n\t// not have MutationObservers.\n\t// Although setImmediate yields to the browser's renderer, it would be\n\t// preferrable to falling back to setTimeout since it does not have\n\t// the minimum 4ms penalty.\n\t// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n\t// Desktop to a lesser extent) that renders both setImmediate and\n\t// MessageChannel useless for the purposes of ASAP.\n\t// https://github.com/kriskowal/q/issues/396\n\n\t// Timers are implemented universally.\n\t// We fall back to timers in workers in most engines, and in foreground\n\t// contexts in the following browsers.\n\t// However, note that even this simple case requires nuances to operate in a\n\t// broad spectrum of browsers.\n\t//\n\t// - Firefox 3-13\n\t// - Internet Explorer 6-9\n\t// - iPad Safari 4.3\n\t// - Lynx 2.8.7\n\t} else {\n\t    requestFlush = makeRequestCallFromTimer(flush);\n\t}\n\n\t// `requestFlush` requests that the high priority event queue be flushed as\n\t// soon as possible.\n\t// This is useful to prevent an error thrown in a task from stalling the event\n\t// queue if the exception handled by Node.jss\n\t// `process.on(\"uncaughtException\")` or by a domain.\n\trawAsap.requestFlush = requestFlush;\n\n\t// To request a high priority event, we induce a mutation observer by toggling\n\t// the text of a text node between \"1\" and \"-1\".\n\tfunction makeRequestCallFromMutationObserver(callback) {\n\t    var toggle = 1;\n\t    var observer = new BrowserMutationObserver(callback);\n\t    var node = document.createTextNode(\"\");\n\t    observer.observe(node, {characterData: true});\n\t    return function requestCall() {\n\t        toggle = -toggle;\n\t        node.data = toggle;\n\t    };\n\t}\n\n\t// The message channel technique was discovered by Malte Ubl and was the\n\t// original foundation for this library.\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\n\n\t// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n\t// page's first load. Thankfully, this version of Safari supports\n\t// MutationObservers, so we don't need to fall back in that case.\n\n\t// function makeRequestCallFromMessageChannel(callback) {\n\t//     var channel = new MessageChannel();\n\t//     channel.port1.onmessage = callback;\n\t//     return function requestCall() {\n\t//         channel.port2.postMessage(0);\n\t//     };\n\t// }\n\n\t// For reasons explained above, we are also unable to use `setImmediate`\n\t// under any circumstances.\n\t// Even if we were, there is another bug in Internet Explorer 10.\n\t// It is not sufficient to assign `setImmediate` to `requestFlush` because\n\t// `setImmediate` must be called *by name* and therefore must be wrapped in a\n\t// closure.\n\t// Never forget.\n\n\t// function makeRequestCallFromSetImmediate(callback) {\n\t//     return function requestCall() {\n\t//         setImmediate(callback);\n\t//     };\n\t// }\n\n\t// Safari 6.0 has a problem where timers will get lost while the user is\n\t// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n\t// mutation observers, so that implementation is used instead.\n\t// However, if we ever elect to use timers in Safari, the prevalent work-around\n\t// is to add a scroll event listener that calls for a flush.\n\n\t// `setTimeout` does not call the passed callback if the delay is less than\n\t// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n\t// even then.\n\n\tfunction makeRequestCallFromTimer(callback) {\n\t    return function requestCall() {\n\t        // We dispatch a timeout with a specified delay of 0 for engines that\n\t        // can reliably accommodate that request. This will usually be snapped\n\t        // to a 4 milisecond delay, but once we're flushing, there's no delay\n\t        // between events.\n\t        var timeoutHandle = setTimeout(handleTimer, 0);\n\t        // However, since this timer gets frequently dropped in Firefox\n\t        // workers, we enlist an interval handle that will try to fire\n\t        // an event 20 times per second until it succeeds.\n\t        var intervalHandle = setInterval(handleTimer, 50);\n\n\t        function handleTimer() {\n\t            // Whichever timer succeeds will cancel both timers and\n\t            // execute the callback.\n\t            clearTimeout(timeoutHandle);\n\t            clearInterval(intervalHandle);\n\t            callback();\n\t        }\n\t    };\n\t}\n\n\t// This is for `asap.js` only.\n\t// Its name will be periodically randomized to break any code that depends on\n\t// its existence.\n\trawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n\t// ASAP was originally a nextTick shim included in Q. This was factored out\n\t// into this ASAP package. It was later adapted to RSVP which made further\n\t// amendments. These decisions, particularly to marginalize MessageChannel and\n\t// to capture the MutationObserver implementation in a closure, were integrated\n\t// back into ASAP proper.\n\t// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ]);"]}}]