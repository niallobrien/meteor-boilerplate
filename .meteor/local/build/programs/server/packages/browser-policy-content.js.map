{"version":3,"sources":["meteor://ðŸ’»app/packages/browser-policy-content/browser-policy-content.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uF","file":"/packages/browser-policy-content.js","sourcesContent":["// By adding this package, you get the following default policy:\n// No eval or other string-to-code, and content can only be loaded from the\n// same origin as the app (except for XHRs and websocket connections, which can\n// go to any origin). Browsers will also be told not to sniff content types\n// away from declared content types (X-Content-Type-Options: nosniff).\n//\n// Apps should call BrowserPolicy.content.disallowInlineScripts() if they are\n// not using any inline script tags and are willing to accept an extra round\n// trip on page load.\n//\n// BrowserPolicy.content functions for tweaking CSP:\n// allowInlineScripts()\n// disallowInlineScripts(): adds extra round-trip to page load time\n// allowInlineStyles()\n// disallowInlineStyles()\n// allowEval()\n// disallowEval()\n//\n// For each type of content (script, object, image, media, font, connect,\n// style), there are the following functions:\n// allow<content type>Origin(origin): allows the type of content to be loaded\n// from the given origin\n// allow<content type>DataUrl(): allows the content to be loaded from data: URLs\n// allow<content type>SameOrigin(): allows the content to be loaded from the\n// same origin\n// disallow<content type>(): disallows this type of content all together (can't\n// be called for script)\n//\n// The following functions allow you to set rules for all types of content at\n// once:\n// allowAllContentOrigin(origin)\n// allowAllContentDataUrl()\n// allowAllContentSameOrigin()\n// disallowAllContent()\n//\n// You can allow content type sniffing by calling\n// `BrowserPolicy.content.allowContentTypeSniffing()`.\n\nvar cspSrcs;\nvar cachedCsp; // Avoid constructing the header out of cspSrcs when possible.\n\n// CSP keywords have to be single-quoted.\nvar keywords = {\n  unsafeInline: \"'unsafe-inline'\",\n  unsafeEval: \"'unsafe-eval'\",\n  self: \"'self'\",\n  none: \"'none'\"\n};\n\n// If false, we set the X-Content-Type-Options header to 'nosniff'.\nvar contentSniffingAllowed = false;\n\nBrowserPolicy.content = {};\n\nvar parseCsp = function (csp) {\n  var policies = csp.split(\"; \");\n  cspSrcs = {};\n  _.each(policies, function (policy) {\n    if (policy[policy.length - 1] === \";\")\n      policy = policy.substring(0, policy.length - 1);\n    var srcs = policy.split(\" \");\n    var directive = srcs[0];\n    if (_.indexOf(srcs, keywords.none) !== -1)\n      cspSrcs[directive] = null;\n    else\n      cspSrcs[directive] = srcs.slice(1);\n  });\n\n  if (cspSrcs[\"default-src\"] === undefined)\n    throw new Error(\"Content Security Policies used with \" +\n                    \"browser-policy must specify a default-src.\");\n\n  // Copy default-src sources to other directives.\n  _.each(cspSrcs, function (sources, directive) {\n    cspSrcs[directive] = _.union(sources || [], cspSrcs[\"default-src\"] || []);\n  });\n};\n\nvar removeCspSrc = function (directive, src) {\n  cspSrcs[directive] = _.without(cspSrcs[directive] || [], src);\n};\n\n// Prepare for a change to cspSrcs. Ensure that we have a key in the dictionary\n// and clear any cached CSP.\nvar prepareForCspDirective = function (directive) {\n  cspSrcs = cspSrcs || {};\n  cachedCsp = null;\n  if (! _.has(cspSrcs, directive))\n    cspSrcs[directive] = _.clone(cspSrcs[\"default-src\"]);\n};\n\n// Add `src` to the list of allowed sources for `directive`, with the\n// following modifications if `src` is an origin:\n// - If `src` does not have a protocol specified, then add both\n//   http://<src> and https://<src>. This is to mask differing\n//   cross-browser behavior; some browsers interpret an origin without a\n//   protocol as http://<src> and some interpret it as both http://<src>\n//   and https://<src>\n// - Trim trailing slashes from `src`, since some browsers interpret\n//   \"foo.com/\" as \"foo.com\" and some don't.\nvar addSourceForDirective = function (directive, src) {\n  if (_.contains(_.values(keywords), src)) {\n    cspSrcs[directive].push(src);\n  } else {\n    src = src.toLowerCase();\n\n    // Trim trailing slashes.\n    src = src.replace(/\\/+$/, '');\n\n    var toAdd = [];\n    // If there is no protocol, add both http:// and https://.\n    if (! /^([a-z0-9.+-]+:)/.test(src)) {\n      toAdd.push(\"http://\" + src);\n      toAdd.push(\"https://\" + src);\n    } else {\n      toAdd.push(src);\n    }\n    _.each(toAdd, function (s) {\n      cspSrcs[directive].push(s);\n    });\n  }\n};\n\nvar setDefaultPolicy = function () {\n  // By default, unsafe inline scripts and styles are allowed, since we expect\n  // many apps will use them for analytics, etc. Unsafe eval is disallowed, and\n  // the only allowable content source is the same origin or data, except for\n  // connect which allows anything (since meteor.com apps make websocket\n  // connections to a lot of different origins).\n  BrowserPolicy.content.setPolicy(\"default-src 'self'; \" +\n                                  \"script-src 'self' 'unsafe-inline'; \" +\n                                  \"connect-src *; \" +\n                                  \"img-src data: 'self'; \" +\n                                  \"style-src 'self' 'unsafe-inline';\");\n  contentSniffingAllowed = false;\n};\n\nvar setWebAppInlineScripts = function (value) {\n  if (! BrowserPolicy._runningTest())\n    WebAppInternals.setInlineScriptsAllowed(value);\n};\n\n_.extend(BrowserPolicy.content, {\n  allowContentTypeSniffing: function () {\n    contentSniffingAllowed = true;\n  },\n  // Exported for tests and browser-policy-common.\n  _constructCsp: function () {\n    if (! cspSrcs || _.isEmpty(cspSrcs))\n      return null;\n\n    if (cachedCsp)\n      return cachedCsp;\n\n    var header = _.map(cspSrcs, function (srcs, directive) {\n      srcs = srcs || [];\n      if (_.isEmpty(srcs))\n        srcs = [keywords.none];\n      var directiveCsp = _.uniq(srcs).join(\" \");\n      return directive + \" \" + directiveCsp + \";\";\n    });\n\n    header = header.join(\" \");\n    cachedCsp = header;\n    return header;\n  },\n  _reset: function () {\n    cachedCsp = null;\n    setDefaultPolicy();\n  },\n\n  setPolicy: function (csp) {\n    cachedCsp = null;\n    parseCsp(csp);\n    setWebAppInlineScripts(\n      BrowserPolicy.content._keywordAllowed(\"script-src\", keywords.unsafeInline)\n    );\n  },\n\n  _keywordAllowed: function (directive, keyword) {\n    return (cspSrcs[directive] &&\n            _.indexOf(cspSrcs[directive], keyword) !== -1);\n  },\n\n  // Helpers for creating content security policies\n\n  allowInlineScripts: function () {\n    prepareForCspDirective(\"script-src\");\n    cspSrcs[\"script-src\"].push(keywords.unsafeInline);\n    setWebAppInlineScripts(true);\n  },\n  disallowInlineScripts: function () {\n    prepareForCspDirective(\"script-src\");\n    removeCspSrc(\"script-src\", keywords.unsafeInline);\n    setWebAppInlineScripts(false);\n  },\n  allowEval: function () {\n    prepareForCspDirective(\"script-src\");\n    cspSrcs[\"script-src\"].push(keywords.unsafeEval);\n  },\n  disallowEval: function () {\n    prepareForCspDirective(\"script-src\");\n    removeCspSrc(\"script-src\", keywords.unsafeEval);\n  },\n  allowInlineStyles: function () {\n    prepareForCspDirective(\"style-src\");\n    cspSrcs[\"style-src\"].push(keywords.unsafeInline);\n  },\n  disallowInlineStyles: function () {\n    prepareForCspDirective(\"style-src\");\n    removeCspSrc(\"style-src\", keywords.unsafeInline);\n  },\n\n  // Functions for setting defaults\n  allowSameOriginForAll: function () {\n    BrowserPolicy.content.allowOriginForAll(keywords.self);\n  },\n  allowDataUrlForAll: function () {\n    BrowserPolicy.content.allowOriginForAll(\"data:\");\n  },\n  allowOriginForAll: function (origin) {\n    prepareForCspDirective(\"default-src\");\n    _.each(_.keys(cspSrcs), function (directive) {\n      addSourceForDirective(directive, origin);\n    });\n  },\n  disallowAll: function () {\n    cachedCsp = null;\n    cspSrcs = {\n      \"default-src\": []\n    };\n    setWebAppInlineScripts(false);\n  },\n\n  _xContentTypeOptions: function () {\n    if (! contentSniffingAllowed) {\n      return \"nosniff\";\n    }\n  }\n});\n\n// allow<Resource>Origin, allow<Resource>Data, allow<Resource>self, and\n// disallow<Resource> methods for each type of resource.\n_.each([\"script\", \"object\", \"img\", \"media\",\n        \"font\", \"connect\", \"style\", \"frame\"],\n       function (resource) {\n         var directive = resource + \"-src\";\n         var methodResource;\n         if (resource !== \"img\") {\n           methodResource = resource.charAt(0).toUpperCase() +\n             resource.slice(1);\n         } else {\n           methodResource = \"Image\";\n         }\n         var allowMethodName = \"allow\" + methodResource + \"Origin\";\n         var disallowMethodName = \"disallow\" + methodResource;\n         var allowDataMethodName = \"allow\" + methodResource + \"DataUrl\";\n         var allowSelfMethodName = \"allow\" + methodResource + \"SameOrigin\";\n\n         var disallow = function () {\n           cachedCsp = null;\n           cspSrcs[directive] = [];\n         };\n\n         BrowserPolicy.content[allowMethodName] = function (src) {\n           prepareForCspDirective(directive);\n           addSourceForDirective(directive, src);\n         };\n         if (resource === \"script\") {\n           BrowserPolicy.content[disallowMethodName] = function () {\n             disallow();\n             setWebAppInlineScripts(false);\n           };\n         } else {\n           BrowserPolicy.content[disallowMethodName] = disallow;\n         }\n         BrowserPolicy.content[allowDataMethodName] = function () {\n           prepareForCspDirective(directive);\n           cspSrcs[directive].push(\"data:\");\n         };\n         BrowserPolicy.content[allowSelfMethodName] = function () {\n           prepareForCspDirective(directive);\n           cspSrcs[directive].push(keywords.self);\n         };\n       });\n\n\nsetDefaultPolicy();\n"]}