{"version":3,"sources":["meteor://ðŸ’»app/packages/mizzao_user-status/packages/mizzao_user-status.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH","file":"/packages/mizzao_user-status.js","sourcesContent":["(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                            //\n// packages/mizzao:user-status/status.coffee.js                                                               //\n//                                                                                                            //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                              //\n__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\n\n/*\n  Apparently, the new api.export takes care of issues here. No need to attach to global namespace.\n  See http://shiggyenterprises.wordpress.com/2013/09/09/meteor-packages-in-coffeescript-0-6-5/\n\n  We may want to make UserSessions a server collection to take advantage of indices.\n  Will implement if someone has enough online users to warrant it.\n */\nvar UserConnections, activeSession, addSession, idleSession, loginSession, onStartup, removeSession, statusEvents, tryLogoutSession;                             \n\nUserConnections = new Mongo.Collection(\"user_status_sessions\", {\n  connection: null\n});\n\nstatusEvents = new (Npm.require('events').EventEmitter)();\n\n\n/*\n  Multiplex login/logout events to status.online\n\n  'online' field is \"true\" if user is online, and \"false\" otherwise\n\n  'idle' field is tri-stated:\n  - \"true\" if user is online and not idle\n  - \"false\" if user is online and idle\n  - null if user is offline\n */\n\nstatusEvents.on(\"connectionLogin\", function(advice) {\n  var conns, update;\n  update = {\n    $set: {\n      'status.online': true,\n      'status.lastLogin': {\n        date: advice.loginTime,\n        ipAddr: advice.ipAddr,\n        userAgent: advice.userAgent\n      }\n    }\n  };\n  conns = UserConnections.find({\n    userId: advice.userId\n  }).fetch();\n  if (!_.every(conns, function(c) {\n    return c.idle;\n  })) {\n    update.$set['status.idle'] = false;\n    update.$unset = {\n      'status.lastActivity': null\n    };\n  }\n  Meteor.users.update(advice.userId, update);\n});\n\nstatusEvents.on(\"connectionLogout\", function(advice) {\n  var conns;\n  conns = UserConnections.find({\n    userId: advice.userId\n  }).fetch();\n  if (conns.length === 0) {\n    Meteor.users.update(advice.userId, {\n      $set: {\n        'status.online': false\n      },\n      $unset: {\n        'status.idle': null,\n        'status.lastActivity': null\n      }\n    });\n  } else if (_.every(conns, function(c) {\n    return c.idle;\n  })) {\n\n    /*\n      All remaining connections are idle:\n      - If the last active connection quit, then we should go idle with the most recent activity\n    \n      - If an idle connection quit, nothing should happen; specifically, if the\n        most recently active idle connection quit, we shouldn't tick the value backwards.\n        This may result in a no-op so we can be smart and skip the update.\n     */\n    if (advice.lastActivity != null) {\n      return;\n    }\n    Meteor.users.update(advice.userId, {\n      $set: {\n        'status.idle': true,\n        'status.lastActivity': _.max(_.pluck(conns, \"lastActivity\"))\n      }\n    });\n  }\n});\n\n\n/*\n  Multiplex idle/active events to status.idle\n  TODO: Hopefully this is quick because it's all in memory, but we can use indices if it turns out to be slow\n\n  TODO: There is a race condition when switching between tabs, leaving the user inactive while idle goes from one tab to the other.\n  It can probably be smoothed out.\n */\n\nstatusEvents.on(\"connectionIdle\", function(advice) {\n  var conns;\n  conns = UserConnections.find({\n    userId: advice.userId\n  }).fetch();\n  if (!_.every(conns, function(c) {\n    return c.idle;\n  })) {\n    return;\n  }\n  Meteor.users.update(advice.userId, {\n    $set: {\n      'status.idle': true,\n      'status.lastActivity': _.max(_.pluck(conns, \"lastActivity\"))\n    }\n  });\n});\n\nstatusEvents.on(\"connectionActive\", function(advice) {\n  Meteor.users.update(advice.userId, {\n    $set: {\n      'status.idle': false\n    },\n    $unset: {\n      'status.lastActivity': null\n    }\n  });\n});\n\nonStartup = function(selector) {\n  if (selector == null) {\n    selector = {};\n  }\n  return Meteor.users.update(selector, {\n    $set: {\n      \"status.online\": false\n    },\n    $unset: {\n      \"status.idle\": null,\n      \"status.lastActivity\": null\n    }\n  }, {\n    multi: true\n  });\n};\n\n\n/*\n  Local session modifification functions - also used in testing\n */\n\naddSession = function(connection) {\n  UserConnections.upsert(connection.id, {\n    $set: {\n      ipAddr: connection.clientAddress,\n      userAgent: connection.httpHeaders['user-agent']\n    }\n  });\n};\n\nloginSession = function(connection, date, userId) {\n  UserConnections.upsert(connection.id, {\n    $set: {\n      userId: userId,\n      loginTime: date\n    }\n  });\n  statusEvents.emit(\"connectionLogin\", {\n    userId: userId,\n    connectionId: connection.id,\n    ipAddr: connection.clientAddress,\n    userAgent: connection.httpHeaders['user-agent'],\n    loginTime: date\n  });\n};\n\ntryLogoutSession = function(connection, date) {\n  var conn;\n  if ((conn = UserConnections.findOne({\n    _id: connection.id,\n    userId: {\n      $exists: true\n    }\n  })) == null) {\n    return false;\n  }\n  UserConnections.upsert(connection.id, {\n    $unset: {\n      userId: null,\n      loginTime: null\n    }\n  });\n  return statusEvents.emit(\"connectionLogout\", {\n    userId: conn.userId,\n    connectionId: connection.id,\n    lastActivity: conn.lastActivity,\n    logoutTime: date\n  });\n};\n\nremoveSession = function(connection, date) {\n  tryLogoutSession(connection, date);\n  UserConnections.remove(connection.id);\n};\n\nidleSession = function(connection, date, userId) {\n  UserConnections.update(connection.id, {\n    $set: {\n      idle: true,\n      lastActivity: date\n    }\n  });\n  statusEvents.emit(\"connectionIdle\", {\n    userId: userId,\n    connectionId: connection.id,\n    lastActivity: date\n  });\n};\n\nactiveSession = function(connection, date, userId) {\n  UserConnections.update(connection.id, {\n    $set: {\n      idle: false\n    },\n    $unset: {\n      lastActivity: null\n    }\n  });\n  statusEvents.emit(\"connectionActive\", {\n    userId: userId,\n    connectionId: connection.id,\n    lastActivity: date\n  });\n};\n\n\n/*\n  Handlers for various client-side events\n */\n\nMeteor.startup(onStartup);\n\nMeteor.onConnection(function(connection) {\n  addSession(connection);\n  return connection.onClose(function() {\n    return removeSession(connection, new Date());\n  });\n});\n\nAccounts.onLogin(function(info) {\n  return loginSession(info.connection, new Date(), info.user._id);\n});\n\nMeteor.publish(null, function() {\n  if (this._session == null) {\n    return [];\n  }\n  if (this.userId == null) {\n    tryLogoutSession(this._session.connectionHandle, new Date());\n  }\n  return [];\n});\n\nMeteor.methods({\n  \"user-status-idle\": function(timestamp) {\n    var date;\n    check(timestamp, Match.OneOf(null, void 0, Date, Number));\n    date = timestamp != null ? new Date(timestamp) : new Date();\n    idleSession(this.connection, date, this.userId);\n  },\n  \"user-status-active\": function(timestamp) {\n    var date;\n    check(timestamp, Match.OneOf(null, void 0, Date, Number));\n    date = timestamp != null ? new Date(timestamp) : new Date();\n    activeSession(this.connection, date, this.userId);\n  }\n});\n\nUserStatus = {\n  connections: UserConnections,\n  events: statusEvents\n};\n\nStatusInternals = {\n  onStartup: onStartup,\n  addSession: addSession,\n  removeSession: removeSession,\n  loginSession: loginSession,\n  tryLogoutSession: tryLogoutSession,\n  idleSession: idleSession,\n  activeSession: activeSession\n};\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}