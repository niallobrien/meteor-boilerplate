{"version":3,"sources":["meteor://ðŸ’»app/packages/aldeed_collection2/packages/aldeed_collection2.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2E","file":"/packages/aldeed_collection2.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/aldeed:collection2/collection2.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/* global Meteor, _, SimpleSchema, Mongo:true, Match, Package, EJSON */                                              // 1\n                                                                                                                     // 2\n// Extend the schema options allowed by SimpleSchema                                                                 // 3\nSimpleSchema.extendOptions({                                                                                         // 4\n  index: Match.Optional(Match.OneOf(Number, String, Boolean)),                                                       // 5\n  unique: Match.Optional(Boolean),                                                                                   // 6\n  sparse: Match.Optional(Boolean),                                                                                   // 7\n  denyInsert: Match.Optional(Boolean),                                                                               // 8\n  denyUpdate: Match.Optional(Boolean)                                                                                // 9\n});                                                                                                                  // 10\n                                                                                                                     // 11\n// Define some extra validation error messages                                                                       // 12\nSimpleSchema.messages({                                                                                              // 13\n  notUnique: \"[label] must be unique\",                                                                               // 14\n  insertNotAllowed: \"[label] cannot be set during an insert\",                                                        // 15\n  updateNotAllowed: \"[label] cannot be set during an update\"                                                         // 16\n});                                                                                                                  // 17\n                                                                                                                     // 18\n/*                                                                                                                   // 19\n * Public API                                                                                                        // 20\n */                                                                                                                  // 21\n                                                                                                                     // 22\n// backwards compatibility                                                                                           // 23\nif (typeof Mongo === \"undefined\") {                                                                                  // 24\n  Mongo = {};                                                                                                        // 25\n  Mongo.Collection = Meteor.Collection;                                                                              // 26\n}                                                                                                                    // 27\n                                                                                                                     // 28\n/**                                                                                                                  // 29\n * Mongo.Collection.prototype.attachSchema                                                                           // 30\n * @param {SimpleSchema|Object} ss - SimpleSchema instance or a schema definition object                             // 31\n *    from which to create a new SimpleSchema instance                                                               // 32\n * @param {Object} [options]                                                                                         // 33\n * @param {Boolean} [options.transform=false] Set to `true` if your document must be passed                          // 34\n *    through the collection's transform to properly validate.                                                       // 35\n * @param {Boolean} [options.replace=false] Set to `true` to replace any existing schema instead of combining        // 36\n * @return {undefined}                                                                                               // 37\n *                                                                                                                   // 38\n * Use this method to attach a schema to a collection created by another package,                                    // 39\n * such as Meteor.users. It is most likely unsafe to call this method more than                                      // 40\n * once for a single collection, or to call this for a collection that had a                                         // 41\n * schema object passed to its constructor.                                                                          // 42\n */                                                                                                                  // 43\nMongo.Collection.prototype.attachSchema = function c2AttachSchema(ss, options) {                                     // 44\n  var self = this;                                                                                                   // 45\n  options = options || {};                                                                                           // 46\n                                                                                                                     // 47\n  if (!(ss instanceof SimpleSchema)) {                                                                               // 48\n    ss = new SimpleSchema(ss);                                                                                       // 49\n  }                                                                                                                  // 50\n                                                                                                                     // 51\n  self._c2 = self._c2 || {};                                                                                         // 52\n                                                                                                                     // 53\n  // If we've already attached one schema, we combine both into a new schema unless options.replace is `true`        // 54\n  if (self._c2._simpleSchema && options.replace !== true) {                                                          // 55\n    ss = new SimpleSchema([self._c2._simpleSchema, ss]);                                                             // 56\n  }                                                                                                                  // 57\n                                                                                                                     // 58\n  // Track the schema in the collection                                                                              // 59\n  self._c2._simpleSchema = ss;                                                                                       // 60\n                                                                                                                     // 61\n  if (self._collection instanceof LocalCollection) {                                                                 // 62\n    self._collection._c2 = self._collection._c2 || {};                                                               // 63\n    self._collection._c2._simpleSchema = ss;                                                                         // 64\n  }                                                                                                                  // 65\n                                                                                                                     // 66\n  function ensureIndex(c, index, indexName, unique, sparse) {                                                        // 67\n    Meteor.startup(function () {                                                                                     // 68\n      c._collection._ensureIndex(index, {                                                                            // 69\n        background: true,                                                                                            // 70\n        name: indexName,                                                                                             // 71\n        unique: unique,                                                                                              // 72\n        sparse: sparse                                                                                               // 73\n      });                                                                                                            // 74\n    });                                                                                                              // 75\n  }                                                                                                                  // 76\n                                                                                                                     // 77\n  function dropIndex(c, indexName) {                                                                                 // 78\n    Meteor.startup(function () {                                                                                     // 79\n      try {                                                                                                          // 80\n        c._collection._dropIndex(indexName);                                                                         // 81\n      } catch (err) {                                                                                                // 82\n        // no index with that name, which is what we want                                                            // 83\n      }                                                                                                              // 84\n    });                                                                                                              // 85\n  }                                                                                                                  // 86\n                                                                                                                     // 87\n  // Loop over fields definitions and ensure collection indexes (server side only)                                   // 88\n  if (Meteor.isServer) {                                                                                             // 89\n    _.each(ss.schema(), function(definition, fieldName) {                                                            // 90\n      if ('index' in definition || definition.unique === true) {                                                     // 91\n        var index = {}, indexValue;                                                                                  // 92\n        // If they specified `unique: true` but not `index`,                                                         // 93\n        // we assume `index: 1` to set up the unique index in mongo                                                  // 94\n        if ('index' in definition) {                                                                                 // 95\n          indexValue = definition.index;                                                                             // 96\n          if (indexValue === true) {                                                                                 // 97\n            indexValue = 1;                                                                                          // 98\n          }                                                                                                          // 99\n        } else {                                                                                                     // 100\n          indexValue = 1;                                                                                            // 101\n        }                                                                                                            // 102\n        var indexName = 'c2_' + fieldName;                                                                           // 103\n        // In the index object, we want object array keys without the \".$\" piece                                     // 104\n        var idxFieldName = fieldName.replace(/\\.\\$\\./g, \".\");                                                        // 105\n        index[idxFieldName] = indexValue;                                                                            // 106\n        var unique = !!definition.unique && (indexValue === 1 || indexValue === -1);                                 // 107\n        var sparse = definition.sparse || false;                                                                     // 108\n                                                                                                                     // 109\n        // If unique and optional, force sparse to prevent errors                                                    // 110\n        if (!sparse && unique && definition.optional) {                                                              // 111\n          sparse = true;                                                                                             // 112\n        }                                                                                                            // 113\n                                                                                                                     // 114\n        if (indexValue === false) {                                                                                  // 115\n          dropIndex(self, indexName);                                                                                // 116\n        } else {                                                                                                     // 117\n          ensureIndex(self, index, indexName, unique, sparse);                                                       // 118\n        }                                                                                                            // 119\n      }                                                                                                              // 120\n    });                                                                                                              // 121\n  }                                                                                                                  // 122\n                                                                                                                     // 123\n  // Set up additional checks                                                                                        // 124\n  ss.validator(function() {                                                                                          // 125\n    var def = this.definition;                                                                                       // 126\n    var val = this.value;                                                                                            // 127\n    var op = this.operator;                                                                                          // 128\n                                                                                                                     // 129\n    if (def.denyInsert && val !== void 0 && !op) {                                                                   // 130\n      // This is an insert of a defined value into a field where denyInsert=true                                     // 131\n      return \"insertNotAllowed\";                                                                                     // 132\n    }                                                                                                                // 133\n                                                                                                                     // 134\n    if (def.denyUpdate && op) {                                                                                      // 135\n      // This is an insert of a defined value into a field where denyUpdate=true                                     // 136\n      if (op !== \"$set\" || (op === \"$set\" && val !== void 0)) {                                                      // 137\n        return \"updateNotAllowed\";                                                                                   // 138\n      }                                                                                                              // 139\n    }                                                                                                                // 140\n                                                                                                                     // 141\n    return true;                                                                                                     // 142\n  });                                                                                                                // 143\n                                                                                                                     // 144\n  defineDeny(self, options);                                                                                         // 145\n  keepInsecure(self);                                                                                                // 146\n};                                                                                                                   // 147\n                                                                                                                     // 148\n_.each([Mongo.Collection, LocalCollection], function (obj) {                                                         // 149\n  obj.prototype.simpleSchema = function () {                                                                         // 150\n    var self = this;                                                                                                 // 151\n    return self._c2 ? self._c2._simpleSchema : null;                                                                 // 152\n  };                                                                                                                 // 153\n});                                                                                                                  // 154\n                                                                                                                     // 155\n// Wrap DB write operation methods                                                                                   // 156\n_.each(['insert', 'update'], function(methodName) {                                                                  // 157\n    var _super = Mongo.Collection.prototype[methodName];                                                             // 158\n    Mongo.Collection.prototype[methodName] = function() {                                                            // 159\n        var self = this,                                                                                             // 160\n            args = _.toArray(arguments);                                                                             // 161\n        if (self._c2) {                                                                                              // 162\n                                                                                                                     // 163\n            var userId = null;                                                                                       // 164\n            try { // https://github.com/aldeed/meteor-collection2/issues/175                                         // 165\n                userId = Meteor.userId();                                                                            // 166\n            } catch (err) {}                                                                                         // 167\n                                                                                                                     // 168\n            args = doValidate.call(                                                                                  // 169\n              self,                                                                                                  // 170\n              methodName,                                                                                            // 171\n              args,                                                                                                  // 172\n              true, // getAutoValues                                                                                 // 173\n              userId,                                                                                                // 174\n              Meteor.isServer // isFromTrustedCode                                                                   // 175\n            );                                                                                                       // 176\n            if (!args) {                                                                                             // 177\n                // doValidate already called the callback or threw the error                                         // 178\n                if (methodName === \"insert\") {                                                                       // 179\n                    // insert should always return an ID to match core behavior                                      // 180\n                    return self._makeNewID();                                                                        // 181\n                } else {                                                                                             // 182\n                    return;                                                                                          // 183\n                }                                                                                                    // 184\n            }                                                                                                        // 185\n        }                                                                                                            // 186\n        return _super.apply(self, args);                                                                             // 187\n    };                                                                                                               // 188\n});                                                                                                                  // 189\n                                                                                                                     // 190\n/*                                                                                                                   // 191\n * Private                                                                                                           // 192\n */                                                                                                                  // 193\n                                                                                                                     // 194\nfunction doValidate(type, args, getAutoValues, userId, isFromTrustedCode) {                                          // 195\n  var self = this, doc, callback, error, options, isUpsert, selector, last, hasCallback;                             // 196\n                                                                                                                     // 197\n  var schema = self.simpleSchema();                                                                                  // 198\n  var isLocalCollection = (self._connection === null);                                                               // 199\n                                                                                                                     // 200\n  if (!args.length) {                                                                                                // 201\n    throw new Error(type + \" requires an argument\");                                                                 // 202\n  }                                                                                                                  // 203\n                                                                                                                     // 204\n  // Gather arguments and cache the selector                                                                         // 205\n  if (type === \"insert\") {                                                                                           // 206\n    doc = args[0];                                                                                                   // 207\n    options = args[1];                                                                                               // 208\n    callback = args[2];                                                                                              // 209\n                                                                                                                     // 210\n    // The real insert doesn't take options                                                                          // 211\n    if (typeof options === \"function\") {                                                                             // 212\n      args = [doc, options];                                                                                         // 213\n    } else if (typeof callback === \"function\") {                                                                     // 214\n      args = [doc, callback];                                                                                        // 215\n    } else {                                                                                                         // 216\n      args = [doc];                                                                                                  // 217\n    }                                                                                                                // 218\n                                                                                                                     // 219\n  } else if (type === \"update\") {                                                                                    // 220\n    selector = args[0];                                                                                              // 221\n    doc = args[1];                                                                                                   // 222\n    options = args[2];                                                                                               // 223\n    callback = args[3];                                                                                              // 224\n  } else {                                                                                                           // 225\n    throw new Error(\"invalid type argument\");                                                                        // 226\n  }                                                                                                                  // 227\n                                                                                                                     // 228\n  // Support missing options arg                                                                                     // 229\n  if (!callback && typeof options === \"function\") {                                                                  // 230\n    callback = options;                                                                                              // 231\n    options = {};                                                                                                    // 232\n  }                                                                                                                  // 233\n  options = options || {};                                                                                           // 234\n                                                                                                                     // 235\n  last = args.length - 1;                                                                                            // 236\n                                                                                                                     // 237\n  hasCallback = (typeof args[last] === 'function');                                                                  // 238\n                                                                                                                     // 239\n  // If update was called with upsert:true, flag as an upsert                                                        // 240\n  isUpsert = (type === \"update\" && options.upsert === true);                                                         // 241\n                                                                                                                     // 242\n  // On the server and for local collections, we allow passing `getAutoValues: false` to disable autoValue functions // 243\n  if ((Meteor.isServer || isLocalCollection) && options.getAutoValues === false) {                                   // 244\n    getAutoValues = false;                                                                                           // 245\n  }                                                                                                                  // 246\n                                                                                                                     // 247\n  // Determine validation context                                                                                    // 248\n  var validationContext = options.validationContext;                                                                 // 249\n  if (validationContext) {                                                                                           // 250\n    if (typeof validationContext === 'string') {                                                                     // 251\n      validationContext = schema.namedContext(validationContext);                                                    // 252\n    }                                                                                                                // 253\n  } else {                                                                                                           // 254\n    validationContext = schema.namedContext();                                                                       // 255\n  }                                                                                                                  // 256\n                                                                                                                     // 257\n  // Add a default callback function if we're on the client and no callback was given                                // 258\n  if (Meteor.isClient && !callback) {                                                                                // 259\n    // Client can't block, so it can't report errors by exception,                                                   // 260\n    // only by callback. If they forget the callback, give them a                                                    // 261\n    // default one that logs the error, so they aren't totally                                                       // 262\n    // baffled if their writes don't work because their database is                                                  // 263\n    // down.                                                                                                         // 264\n    callback = function(err) {                                                                                       // 265\n      if (err) {                                                                                                     // 266\n        Meteor._debug(type + \" failed: \" + (err.reason || err.stack));                                               // 267\n      }                                                                                                              // 268\n    };                                                                                                               // 269\n  }                                                                                                                  // 270\n                                                                                                                     // 271\n  // If client validation is fine or is skipped but then something                                                   // 272\n  // is found to be invalid on the server, we get that error back                                                    // 273\n  // as a special Meteor.Error that we need to parse.                                                                // 274\n  if (Meteor.isClient && hasCallback) {                                                                              // 275\n    callback = args[last] = wrapCallbackForParsingServerErrors(validationContext, callback);                         // 276\n  }                                                                                                                  // 277\n                                                                                                                     // 278\n  // Get the docId for passing in the autoValue/custom context                                                       // 279\n  var docId;                                                                                                         // 280\n  if (type === 'insert') {                                                                                           // 281\n    docId = doc._id; // might be undefined                                                                           // 282\n  } else if (type === \"update\" && selector) {                                                                        // 283\n    docId = typeof selector === 'string' || selector instanceof Mongo.ObjectID ? selector : selector._id;            // 284\n  }                                                                                                                  // 285\n                                                                                                                     // 286\n  // If _id has already been added, remove it temporarily if it's                                                    // 287\n  // not explicitly defined in the schema.                                                                           // 288\n  var cachedId;                                                                                                      // 289\n  if (doc._id && !schema.allowsKey(\"_id\")) {                                                                         // 290\n    cachedId = doc._id;                                                                                              // 291\n    delete doc._id;                                                                                                  // 292\n  }                                                                                                                  // 293\n                                                                                                                     // 294\n  function doClean(docToClean, getAutoValues, filter, autoConvert, removeEmptyStrings, trimStrings) {                // 295\n    // Clean the doc/modifier in place                                                                               // 296\n    schema.clean(docToClean, {                                                                                       // 297\n      filter: filter,                                                                                                // 298\n      autoConvert: autoConvert,                                                                                      // 299\n      getAutoValues: getAutoValues,                                                                                  // 300\n      isModifier: (type !== \"insert\"),                                                                               // 301\n      removeEmptyStrings: removeEmptyStrings,                                                                        // 302\n      trimStrings: trimStrings,                                                                                      // 303\n      extendAutoValueContext: _.extend({                                                                             // 304\n        isInsert: (type === \"insert\"),                                                                               // 305\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 306\n        isUpsert: isUpsert,                                                                                          // 307\n        userId: userId,                                                                                              // 308\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 309\n        docId: docId,                                                                                                // 310\n        isLocalCollection: isLocalCollection                                                                         // 311\n      }, options.extendAutoValueContext || {})                                                                       // 312\n    });                                                                                                              // 313\n  }                                                                                                                  // 314\n                                                                                                                     // 315\n  // Preliminary cleaning on both client and server. On the server and for local                                     // 316\n  // collections, automatic values will also be set at this point.                                                   // 317\n  doClean(                                                                                                           // 318\n    doc,                                                                                                             // 319\n    getAutoValues,                                                                                                   // 320\n    options.filter !== false,                                                                                        // 321\n    options.autoConvert !== false,                                                                                   // 322\n    options.removeEmptyStrings !== false,                                                                            // 323\n    options.trimStrings !== false                                                                                    // 324\n  );                                                                                                                 // 325\n                                                                                                                     // 326\n  // We clone before validating because in some cases we need to adjust the                                          // 327\n  // object a bit before validating it. If we adjusted `doc` itself, our                                             // 328\n  // changes would persist into the database.                                                                        // 329\n  var docToValidate = {};                                                                                            // 330\n  for (var prop in doc) {                                                                                            // 331\n    // We omit prototype properties when cloning because they will not be valid                                      // 332\n    // and mongo omits them when saving to the database anyway.                                                      // 333\n    if (doc.hasOwnProperty(prop)) {                                                                                  // 334\n      docToValidate[prop] = doc[prop];                                                                               // 335\n    }                                                                                                                // 336\n  }                                                                                                                  // 337\n                                                                                                                     // 338\n  // On the server, upserts are possible; SimpleSchema handles upserts pretty                                        // 339\n  // well by default, but it will not know about the fields in the selector,                                         // 340\n  // which are also stored in the database if an insert is performed. So we                                          // 341\n  // will allow these fields to be considered for validation by adding them                                          // 342\n  // to the $set in the modifier. This is no doubt prone to errors, but there                                        // 343\n  // probably isn't any better way right now.                                                                        // 344\n  if (Meteor.isServer && isUpsert && _.isObject(selector)) {                                                         // 345\n    var set = docToValidate.$set || {};                                                                              // 346\n    docToValidate.$set = _.clone(selector);                                                                          // 347\n    _.extend(docToValidate.$set, set);                                                                               // 348\n  }                                                                                                                  // 349\n                                                                                                                     // 350\n  // Set automatic values for validation on the client.                                                              // 351\n  // On the server, we already updated doc with auto values, but on the client,                                      // 352\n  // we will add them to docToValidate for validation purposes only.                                                 // 353\n  // This is because we want all actual values generated on the server.                                              // 354\n  if (Meteor.isClient && !isLocalCollection) {                                                                       // 355\n    doClean(docToValidate, true, false, false, false, false);                                                        // 356\n  }                                                                                                                  // 357\n                                                                                                                     // 358\n  // Validate doc                                                                                                    // 359\n  var isValid;                                                                                                       // 360\n  if (options.validate === false) {                                                                                  // 361\n    isValid = true;                                                                                                  // 362\n  } else {                                                                                                           // 363\n    isValid = validationContext.validate(docToValidate, {                                                            // 364\n      modifier: (type === \"update\" || type === \"upsert\"),                                                            // 365\n      upsert: isUpsert,                                                                                              // 366\n      extendedCustomContext: _.extend({                                                                              // 367\n        isInsert: (type === \"insert\"),                                                                               // 368\n        isUpdate: (type === \"update\" && options.upsert !== true),                                                    // 369\n        isUpsert: isUpsert,                                                                                          // 370\n        userId: userId,                                                                                              // 371\n        isFromTrustedCode: isFromTrustedCode,                                                                        // 372\n        docId: docId,                                                                                                // 373\n        isLocalCollection: isLocalCollection                                                                         // 374\n      }, options.extendedCustomContext || {})                                                                        // 375\n    });                                                                                                              // 376\n  }                                                                                                                  // 377\n                                                                                                                     // 378\n  if (isValid) {                                                                                                     // 379\n    // Add the ID back                                                                                               // 380\n    if (cachedId) {                                                                                                  // 381\n      doc._id = cachedId;                                                                                            // 382\n    }                                                                                                                // 383\n                                                                                                                     // 384\n    // Update the args to reflect the cleaned doc                                                                    // 385\n    // XXX not sure this is necessary since we mutate                                                                // 386\n    if (type === \"insert\") {                                                                                         // 387\n      args[0] = doc;                                                                                                 // 388\n    } else {                                                                                                         // 389\n      args[1] = doc;                                                                                                 // 390\n    }                                                                                                                // 391\n                                                                                                                     // 392\n    // If callback, set invalidKey when we get a mongo unique error                                                  // 393\n    if (Meteor.isServer && hasCallback) {                                                                            // 394\n      args[last] = wrapCallbackForParsingMongoValidationErrors(validationContext, args[last]);                       // 395\n    }                                                                                                                // 396\n                                                                                                                     // 397\n    return args;                                                                                                     // 398\n  } else {                                                                                                           // 399\n    error = getErrorObject(validationContext);                                                                       // 400\n    if (callback) {                                                                                                  // 401\n      // insert/update/upsert pass `false` when there's an error, so we do that                                      // 402\n      callback(error, false);                                                                                        // 403\n    } else {                                                                                                         // 404\n      throw error;                                                                                                   // 405\n    }                                                                                                                // 406\n  }                                                                                                                  // 407\n}                                                                                                                    // 408\n                                                                                                                     // 409\nfunction getErrorObject(context) {                                                                                   // 410\n  var message, invalidKeys = context.invalidKeys();                                                                  // 411\n  if (invalidKeys.length) {                                                                                          // 412\n    message = context.keyErrorMessage(invalidKeys[0].name);                                                          // 413\n  } else {                                                                                                           // 414\n    message = \"Failed validation\";                                                                                   // 415\n  }                                                                                                                  // 416\n  var error = new Error(message);                                                                                    // 417\n  error.invalidKeys = invalidKeys;                                                                                   // 418\n  error.validationContext = context;                                                                                 // 419\n  // If on the server, we add a sanitized error, too, in case we're                                                  // 420\n  // called from a method.                                                                                           // 421\n  if (Meteor.isServer) {                                                                                             // 422\n    error.sanitizedError = new Meteor.Error(400, message, EJSON.stringify(error.invalidKeys));                       // 423\n  }                                                                                                                  // 424\n  return error;                                                                                                      // 425\n}                                                                                                                    // 426\n                                                                                                                     // 427\nfunction addUniqueError(context, errorMessage) {                                                                     // 428\n  var name = errorMessage.split('c2_')[1].split(' ')[0];                                                             // 429\n  var val = errorMessage.split('dup key:')[1].split('\"')[1];                                                         // 430\n  context.addInvalidKeys([{                                                                                          // 431\n    name: name,                                                                                                      // 432\n    type: 'notUnique',                                                                                               // 433\n    value: val                                                                                                       // 434\n  }]);                                                                                                               // 435\n}                                                                                                                    // 436\n                                                                                                                     // 437\nfunction wrapCallbackForParsingMongoValidationErrors(validationContext, cb) {                                        // 438\n  return function wrappedCallbackForParsingMongoValidationErrors(error) {                                            // 439\n    var args = _.toArray(arguments);                                                                                 // 440\n    if (error &&                                                                                                     // 441\n        ((error.name === \"MongoError\" && error.code === 11001) || error.message.indexOf('MongoError: E11000' !== -1)) &&\n        error.message.indexOf('c2_') !== -1) {                                                                       // 443\n      addUniqueError(validationContext, error.message);                                                              // 444\n      args[0] = getErrorObject(validationContext);                                                                   // 445\n    }                                                                                                                // 446\n    return cb.apply(this, args);                                                                                     // 447\n  };                                                                                                                 // 448\n}                                                                                                                    // 449\n                                                                                                                     // 450\nfunction wrapCallbackForParsingServerErrors(validationContext, cb) {                                                 // 451\n  return function wrappedCallbackForParsingServerErrors(error) {                                                     // 452\n    var args = _.toArray(arguments);                                                                                 // 453\n    // Handle our own validation errors                                                                              // 454\n    if (error instanceof Meteor.Error &&                                                                             // 455\n        error.error === 400 &&                                                                                       // 456\n        error.reason === \"INVALID\" &&                                                                                // 457\n        typeof error.details === \"string\") {                                                                         // 458\n      var invalidKeysFromServer = EJSON.parse(error.details);                                                        // 459\n      validationContext.addInvalidKeys(invalidKeysFromServer);                                                       // 460\n      args[0] = getErrorObject(validationContext);                                                                   // 461\n    }                                                                                                                // 462\n    // Handle Mongo unique index errors, which are forwarded to the client as 409 errors                             // 463\n    else if (error instanceof Meteor.Error &&                                                                        // 464\n             error.error === 409 &&                                                                                  // 465\n             error.reason &&                                                                                         // 466\n             error.reason.indexOf('E11000') !== -1 &&                                                                // 467\n             error.reason.indexOf('c2_') !== -1) {                                                                   // 468\n      addUniqueError(validationContext, error.reason);                                                               // 469\n      args[0] = getErrorObject(validationContext);                                                                   // 470\n    }                                                                                                                // 471\n    return cb.apply(this, args);                                                                                     // 472\n  };                                                                                                                 // 473\n}                                                                                                                    // 474\n                                                                                                                     // 475\nvar alreadyInsecured = {};                                                                                           // 476\nfunction keepInsecure(c) {                                                                                           // 477\n  // If insecure package is in use, we need to add allow rules that return                                           // 478\n  // true. Otherwise, it would seemingly turn off insecure mode.                                                     // 479\n  if (Package && Package.insecure && !alreadyInsecured[c._name]) {                                                   // 480\n    c.allow({                                                                                                        // 481\n      insert: function() {                                                                                           // 482\n        return true;                                                                                                 // 483\n      },                                                                                                             // 484\n      update: function() {                                                                                           // 485\n        return true;                                                                                                 // 486\n      },                                                                                                             // 487\n      remove: function () {                                                                                          // 488\n        return true;                                                                                                 // 489\n      },                                                                                                             // 490\n      fetch: [],                                                                                                     // 491\n      transform: null                                                                                                // 492\n    });                                                                                                              // 493\n    alreadyInsecured[c._name] = true;                                                                                // 494\n  }                                                                                                                  // 495\n  // If insecure package is NOT in use, then adding the two deny functions                                           // 496\n  // does not have any effect on the main app's security paradigm. The                                               // 497\n  // user will still be required to add at least one allow function of her                                           // 498\n  // own for each operation for this collection. And the user may still add                                          // 499\n  // additional deny functions, but does not have to.                                                                // 500\n}                                                                                                                    // 501\n                                                                                                                     // 502\nvar alreadyDefined = {};                                                                                             // 503\nfunction defineDeny(c, options) {                                                                                    // 504\n  if (!alreadyDefined[c._name]) {                                                                                    // 505\n                                                                                                                     // 506\n    var isLocalCollection = (c._connection === null);                                                                // 507\n                                                                                                                     // 508\n    // First define deny functions to extend doc with the results of clean                                           // 509\n    // and autovalues. This must be done with \"transform: null\" or we would be                                       // 510\n    // extending a clone of doc and therefore have no effect.                                                        // 511\n    c.deny({                                                                                                         // 512\n      insert: function(userId, doc) {                                                                                // 513\n        var ss = c.simpleSchema();                                                                                   // 514\n        // If _id has already been added, remove it temporarily if it's                                              // 515\n        // not explicitly defined in the schema.                                                                     // 516\n        var id;                                                                                                      // 517\n        if (Meteor.isServer && doc._id && !ss.allowsKey(\"_id\")) {                                                    // 518\n          id = doc._id;                                                                                              // 519\n          delete doc._id;                                                                                            // 520\n        }                                                                                                            // 521\n                                                                                                                     // 522\n        // Referenced doc is cleaned in place                                                                        // 523\n        ss.clean(doc, {                                                                                              // 524\n          isModifier: false,                                                                                         // 525\n          // We don't do these here because they are done on the client if desired                                   // 526\n          filter: false,                                                                                             // 527\n          autoConvert: false,                                                                                        // 528\n          removeEmptyStrings: false,                                                                                 // 529\n          trimStrings: false,                                                                                        // 530\n          extendAutoValueContext: {                                                                                  // 531\n            isInsert: true,                                                                                          // 532\n            isUpdate: false,                                                                                         // 533\n            isUpsert: false,                                                                                         // 534\n            userId: userId,                                                                                          // 535\n            isFromTrustedCode: false,                                                                                // 536\n            docId: id,                                                                                               // 537\n            isLocalCollection: isLocalCollection                                                                     // 538\n          }                                                                                                          // 539\n        });                                                                                                          // 540\n                                                                                                                     // 541\n        // Add the ID back                                                                                           // 542\n        if (id) {                                                                                                    // 543\n          doc._id = id;                                                                                              // 544\n        }                                                                                                            // 545\n                                                                                                                     // 546\n        return false;                                                                                                // 547\n      },                                                                                                             // 548\n      update: function(userId, doc, fields, modifier) {                                                              // 549\n        var ss = c.simpleSchema();                                                                                   // 550\n        // Referenced modifier is cleaned in place                                                                   // 551\n        ss.clean(modifier, {                                                                                         // 552\n          isModifier: true,                                                                                          // 553\n          // We don't do these here because they are done on the client if desired                                   // 554\n          filter: false,                                                                                             // 555\n          autoConvert: false,                                                                                        // 556\n          removeEmptyStrings: false,                                                                                 // 557\n          trimStrings: false,                                                                                        // 558\n          extendAutoValueContext: {                                                                                  // 559\n            isInsert: false,                                                                                         // 560\n            isUpdate: true,                                                                                          // 561\n            isUpsert: false,                                                                                         // 562\n            userId: userId,                                                                                          // 563\n            isFromTrustedCode: false,                                                                                // 564\n            docId: doc && doc._id,                                                                                   // 565\n            isLocalCollection: isLocalCollection                                                                     // 566\n          }                                                                                                          // 567\n        });                                                                                                          // 568\n                                                                                                                     // 569\n        return false;                                                                                                // 570\n      },                                                                                                             // 571\n      fetch: ['_id'],                                                                                                // 572\n      transform: null                                                                                                // 573\n    });                                                                                                              // 574\n                                                                                                                     // 575\n    // Second define deny functions to validate again on the server                                                  // 576\n    // for client-initiated inserts and updates. These should be                                                     // 577\n    // called after the clean/autovalue functions since we're adding                                                 // 578\n    // them after. These must *not* have \"transform: null\" if options.transform is true because                      // 579\n    // we need to pass the doc through any transforms to be sure                                                     // 580\n    // that custom types are properly recognized for type validation.                                                // 581\n    c.deny(_.extend({                                                                                                // 582\n      insert: function(userId, doc) {                                                                                // 583\n        // We pass the false options because we will have done them on client if desired                             // 584\n        doValidate.call(                                                                                             // 585\n          c,                                                                                                         // 586\n          \"insert\",                                                                                                  // 587\n          [                                                                                                          // 588\n            doc,                                                                                                     // 589\n            {                                                                                                        // 590\n              trimStrings: false,                                                                                    // 591\n              removeEmptyStrings: false,                                                                             // 592\n              filter: false,                                                                                         // 593\n              autoConvert: false                                                                                     // 594\n            },                                                                                                       // 595\n            function(error) {                                                                                        // 596\n              if (error) {                                                                                           // 597\n                throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                          // 598\n              }                                                                                                      // 599\n            }                                                                                                        // 600\n          ],                                                                                                         // 601\n          false, // getAutoValues                                                                                    // 602\n          userId,                                                                                                    // 603\n          false // isFromTrustedCode                                                                                 // 604\n        );                                                                                                           // 605\n                                                                                                                     // 606\n        return false;                                                                                                // 607\n      },                                                                                                             // 608\n      update: function(userId, doc, fields, modifier) {                                                              // 609\n        // NOTE: This will never be an upsert because client-side upserts                                            // 610\n        // are not allowed once you define allow/deny functions.                                                     // 611\n        // We pass the false options because we will have done them on client if desired                             // 612\n        doValidate.call(                                                                                             // 613\n          c,                                                                                                         // 614\n          \"update\",                                                                                                  // 615\n          [                                                                                                          // 616\n            {_id: doc && doc._id},                                                                                   // 617\n            modifier,                                                                                                // 618\n            {                                                                                                        // 619\n              trimStrings: false,                                                                                    // 620\n              removeEmptyStrings: false,                                                                             // 621\n              filter: false,                                                                                         // 622\n              autoConvert: false                                                                                     // 623\n            },                                                                                                       // 624\n            function(error) {                                                                                        // 625\n              if (error) {                                                                                           // 626\n                throw new Meteor.Error(400, 'INVALID', EJSON.stringify(error.invalidKeys));                          // 627\n              }                                                                                                      // 628\n            }                                                                                                        // 629\n          ],                                                                                                         // 630\n          false, // getAutoValues                                                                                    // 631\n          userId,                                                                                                    // 632\n          false // isFromTrustedCode                                                                                 // 633\n        );                                                                                                           // 634\n                                                                                                                     // 635\n        return false;                                                                                                // 636\n      },                                                                                                             // 637\n      fetch: ['_id']                                                                                                 // 638\n    }, options.transform === true ? {} : {transform: null}));                                                        // 639\n                                                                                                                     // 640\n    // note that we've already done this collection so that we don't do it again                                     // 641\n    // if attachSchema is called again                                                                               // 642\n    alreadyDefined[c._name] = true;                                                                                  // 643\n  }                                                                                                                  // 644\n}                                                                                                                    // 645\n                                                                                                                     // 646\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}